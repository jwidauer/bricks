<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=9" />
    <meta name="generator" content="Doxygen 1.9.5" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>BRICKS: bricks::result&lt; T, E &gt; Class Template Reference</title>
    <link href="tabs.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript">
        DoxygenAwesomeDarkModeToggle.init()
    </script>
    <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
    <script type="text/javascript">
        DoxygenAwesomeFragmentCopyButton.init()
    </script>
    <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
    <script type="text/javascript">
        DoxygenAwesomeParagraphLink.init()
    </script>
    <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
    <script type="text/javascript">
        DoxygenAwesomeInteractiveToc.init()
    </script>
</head>
<body>
    <div id="top">
        <!-- do not remove this div, it is closed by doxygen! -->
        <div id="titlearea">
            <table cellspacing="0" cellpadding="0">
                <tbody>
                    <tr style="height: 56px;">
                        <td id="projectlogo"><img alt="Logo" src="logo.png" /></td>
                        <td id="projectalign" style="padding-left: 0.5em;">
                            <div id="projectname">BRICKS
                            </div>
                            <div id="projectbrief">Small, useful blocks of code, to build bigger things.</div>
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
        <!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classbricks_1_1result.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classbricks_1_1result-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">bricks::result&lt; T, E &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A class to represent the result of an operation.  
 <a href="classbricks_1_1result.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="result_8hpp_source.html">result.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a21aebcf1057005dc1fe041cbd5a3cd5c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbricks_1_1result.html#a21aebcf1057005dc1fe041cbd5a3cd5c">value_type</a> = T</td></tr>
<tr class="memdesc:a21aebcf1057005dc1fe041cbd5a3cd5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value type of the result.  <a href="classbricks_1_1result.html#a21aebcf1057005dc1fe041cbd5a3cd5c">More...</a><br /></td></tr>
<tr class="separator:a21aebcf1057005dc1fe041cbd5a3cd5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b8311e26db21f89e2482a499ef13b6c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbricks_1_1result.html#a9b8311e26db21f89e2482a499ef13b6c">error_type</a> = E</td></tr>
<tr class="memdesc:a9b8311e26db21f89e2482a499ef13b6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The error type of the result.  <a href="classbricks_1_1result.html#a9b8311e26db21f89e2482a499ef13b6c">More...</a><br /></td></tr>
<tr class="separator:a9b8311e26db21f89e2482a499ef13b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7ccc36f39e6dd02c9ecbbabe4960c220"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbricks_1_1result.html#a7ccc36f39e6dd02c9ecbbabe4960c220">result</a> ()=delete</td></tr>
<tr class="separator:a7ccc36f39e6dd02c9ecbbabe4960c220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff8d1bec8d5a22f1224ab2731827222a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbricks_1_1result.html#aff8d1bec8d5a22f1224ab2731827222a">result</a> (const <a class="el" href="classbricks_1_1result.html">result</a> &amp;) noexcept(std::is_nothrow_copy_constructible_v&lt; variant_t &gt;)=default</td></tr>
<tr class="separator:aff8d1bec8d5a22f1224ab2731827222a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a6ba51579f60baccb3c930aec1ac92"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbricks_1_1result.html#aa3a6ba51579f60baccb3c930aec1ac92">operator=</a> (const <a class="el" href="classbricks_1_1result.html">result</a> &amp;) noexcept(std::is_nothrow_copy_assignable_v&lt; variant_t &gt;) -&gt; <a class="el" href="classbricks_1_1result.html">result</a> &amp;=default</td></tr>
<tr class="separator:aa3a6ba51579f60baccb3c930aec1ac92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae355663cd439ad0f1aef1ffd0336bc82"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbricks_1_1result.html#ae355663cd439ad0f1aef1ffd0336bc82">result</a> (<a class="el" href="classbricks_1_1result.html">result</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="separator:ae355663cd439ad0f1aef1ffd0336bc82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1307052d75f3bd58abdc392400bfd95"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbricks_1_1result.html#ae1307052d75f3bd58abdc392400bfd95">operator=</a> (<a class="el" href="classbricks_1_1result.html">result</a> &amp;&amp;) noexcept -&gt; <a class="el" href="classbricks_1_1result.html">result</a> &amp;=default</td></tr>
<tr class="separator:ae1307052d75f3bd58abdc392400bfd95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04f4c2252597e0ea52ec5d0324165207"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbricks_1_1result.html#a04f4c2252597e0ea52ec5d0324165207">~result</a> ()=default</td></tr>
<tr class="separator:a04f4c2252597e0ea52ec5d0324165207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5d62d4703512f55841c95708a807f04"><td class="memTemplParams" colspan="2">template&lt;typename U , typename std::enable_if_t&lt; std::is_same_v&lt; U, <a class="el" href="namespacebricks.html#a19b2ba7d93c79fd196404d3fc50eac4f">ok</a>&lt; T &gt; &gt;||std::is_same_v&lt; U, <a class="el" href="namespacebricks.html#a56141134ef4783cc27e2f3e970dbedf5">err</a>&lt; E &gt; &gt;, bool &gt;  = true&gt; </td></tr>
<tr class="memitem:aa5d62d4703512f55841c95708a807f04"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbricks_1_1result.html#aa5d62d4703512f55841c95708a807f04">result</a> (U in) noexcept(std::is_nothrow_move_constructible_v&lt; U &gt;)</td></tr>
<tr class="memdesc:aa5d62d4703512f55841c95708a807f04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new result object from a value.  <a href="classbricks_1_1result.html#aa5d62d4703512f55841c95708a807f04">More...</a><br /></td></tr>
<tr class="separator:aa5d62d4703512f55841c95708a807f04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afae47e70bcb7b32ba38cbceb2ed0d4fb"><td class="memTemplParams" colspan="2">template&lt;typename U  = T, typename std::enable_if_t&lt;!std::is_same_v&lt; U, E &gt;, bool &gt;  = true&gt; </td></tr>
<tr class="memitem:afae47e70bcb7b32ba38cbceb2ed0d4fb"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbricks_1_1result.html#afae47e70bcb7b32ba38cbceb2ed0d4fb">result</a> (<a class="el" href="classbricks_1_1result.html#a21aebcf1057005dc1fe041cbd5a3cd5c">value_type</a> in) noexcept(std::is_nothrow_move_constructible_v&lt; <a class="el" href="namespacebricks.html#a19b2ba7d93c79fd196404d3fc50eac4f">ok</a>&lt; T &gt; &gt;)</td></tr>
<tr class="separator:afae47e70bcb7b32ba38cbceb2ed0d4fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c2d611cae957befd497ccace779a94"><td class="memTemplParams" colspan="2">template&lt;typename U  = E, typename std::enable_if_t&lt;!std::is_same_v&lt; T, U &gt;, bool &gt;  = true&gt; </td></tr>
<tr class="memitem:ac0c2d611cae957befd497ccace779a94"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbricks_1_1result.html#ac0c2d611cae957befd497ccace779a94">result</a> (<a class="el" href="classbricks_1_1result.html#a9b8311e26db21f89e2482a499ef13b6c">error_type</a> in) noexcept(std::is_nothrow_move_constructible_v&lt; <a class="el" href="namespacebricks.html#a56141134ef4783cc27e2f3e970dbedf5">err</a>&lt; E &gt; &gt;)</td></tr>
<tr class="separator:ac0c2d611cae957befd497ccace779a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4bd155e31761eef73f6f6d216ec7b6d"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:af4bd155e31761eef73f6f6d216ec7b6d"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbricks_1_1result.html#af4bd155e31761eef73f6f6d216ec7b6d">operator=</a> (U in) noexcept -&gt; <a class="el" href="classbricks_1_1result.html">result</a> &amp;</td></tr>
<tr class="memdesc:af4bd155e31761eef73f6f6d216ec7b6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign a value to the result.  <a href="classbricks_1_1result.html#af4bd155e31761eef73f6f6d216ec7b6d">More...</a><br /></td></tr>
<tr class="separator:af4bd155e31761eef73f6f6d216ec7b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a208708da81a03492f0c0186adbbad67e"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbricks_1_1result.html#a208708da81a03492f0c0186adbbad67e">is_value</a> () const noexcept -&gt; bool</td></tr>
<tr class="memdesc:a208708da81a03492f0c0186adbbad67e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the result is a value.  <a href="classbricks_1_1result.html#a208708da81a03492f0c0186adbbad67e">More...</a><br /></td></tr>
<tr class="separator:a208708da81a03492f0c0186adbbad67e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86cdaac204681255c6c48ac3bc753b7f"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbricks_1_1result.html#a86cdaac204681255c6c48ac3bc753b7f">is_error</a> () const noexcept -&gt; bool</td></tr>
<tr class="memdesc:a86cdaac204681255c6c48ac3bc753b7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the result is an error.  <a href="classbricks_1_1result.html#a86cdaac204681255c6c48ac3bc753b7f">More...</a><br /></td></tr>
<tr class="separator:a86cdaac204681255c6c48ac3bc753b7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92bf3bf0dfe7b1797589fe498dc98b3c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbricks_1_1result.html#a92bf3bf0dfe7b1797589fe498dc98b3c">expect</a> (const std::string &amp;msg) const -&gt; <a class="el" href="classbricks_1_1result.html#a21aebcf1057005dc1fe041cbd5a3cd5c">value_type</a></td></tr>
<tr class="memdesc:a92bf3bf0dfe7b1797589fe498dc98b3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the result.  <a href="classbricks_1_1result.html#a92bf3bf0dfe7b1797589fe498dc98b3c">More...</a><br /></td></tr>
<tr class="separator:a92bf3bf0dfe7b1797589fe498dc98b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b984365b5611cafe6c5ad8ebfa3fa9c"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbricks_1_1result.html#a6b984365b5611cafe6c5ad8ebfa3fa9c">unwrap</a> () const -&gt; <a class="el" href="classbricks_1_1result.html#a21aebcf1057005dc1fe041cbd5a3cd5c">value_type</a></td></tr>
<tr class="memdesc:a6b984365b5611cafe6c5ad8ebfa3fa9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the result.  <a href="classbricks_1_1result.html#a6b984365b5611cafe6c5ad8ebfa3fa9c">More...</a><br /></td></tr>
<tr class="separator:a6b984365b5611cafe6c5ad8ebfa3fa9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d75a95f5125b0535eca50e278fb2b6f"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbricks_1_1result.html#a8d75a95f5125b0535eca50e278fb2b6f">expect_error</a> (const std::string &amp;msg) const -&gt; <a class="el" href="classbricks_1_1result.html#a9b8311e26db21f89e2482a499ef13b6c">error_type</a></td></tr>
<tr class="memdesc:a8d75a95f5125b0535eca50e278fb2b6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the error of the result.  <a href="classbricks_1_1result.html#a8d75a95f5125b0535eca50e278fb2b6f">More...</a><br /></td></tr>
<tr class="separator:a8d75a95f5125b0535eca50e278fb2b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2f4125f05de654ebb7033939dd1de51"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbricks_1_1result.html#aa2f4125f05de654ebb7033939dd1de51">unwrap_error</a> () const -&gt; <a class="el" href="classbricks_1_1result.html#a9b8311e26db21f89e2482a499ef13b6c">error_type</a></td></tr>
<tr class="memdesc:aa2f4125f05de654ebb7033939dd1de51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the error of the result.  <a href="classbricks_1_1result.html#aa2f4125f05de654ebb7033939dd1de51">More...</a><br /></td></tr>
<tr class="separator:aa2f4125f05de654ebb7033939dd1de51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc5b09e34960d2afbcae03264a65f595"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbricks_1_1result.html#adc5b09e34960d2afbcae03264a65f595">unwrap_or</a> (<a class="el" href="classbricks_1_1result.html#a21aebcf1057005dc1fe041cbd5a3cd5c">value_type</a> default_value) const noexcept -&gt; <a class="el" href="classbricks_1_1result.html#a21aebcf1057005dc1fe041cbd5a3cd5c">value_type</a></td></tr>
<tr class="memdesc:adc5b09e34960d2afbcae03264a65f595"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the result.  <a href="classbricks_1_1result.html#adc5b09e34960d2afbcae03264a65f595">More...</a><br /></td></tr>
<tr class="separator:adc5b09e34960d2afbcae03264a65f595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaccfa91669612eaa548f3e889d6bc43"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbricks_1_1result.html#abaccfa91669612eaa548f3e889d6bc43">unwrap_or_default</a> () const noexcept -&gt; <a class="el" href="classbricks_1_1result.html#a21aebcf1057005dc1fe041cbd5a3cd5c">value_type</a></td></tr>
<tr class="memdesc:abaccfa91669612eaa548f3e889d6bc43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the result or a default constructed value.  <a href="classbricks_1_1result.html#abaccfa91669612eaa548f3e889d6bc43">More...</a><br /></td></tr>
<tr class="separator:abaccfa91669612eaa548f3e889d6bc43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab467ecbc8adfc40cce5196ca220bc07c"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:ab467ecbc8adfc40cce5196ca220bc07c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbricks_1_1result.html#ab467ecbc8adfc40cce5196ca220bc07c">unwrap_or_else</a> (F &amp;&amp;f) const -&gt; <a class="el" href="classbricks_1_1result.html#a21aebcf1057005dc1fe041cbd5a3cd5c">value_type</a></td></tr>
<tr class="memdesc:ab467ecbc8adfc40cce5196ca220bc07c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the result or the result of a function.  <a href="classbricks_1_1result.html#ab467ecbc8adfc40cce5196ca220bc07c">More...</a><br /></td></tr>
<tr class="separator:ab467ecbc8adfc40cce5196ca220bc07c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a702d25e354097a9c7a792f42064c4f78"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a702d25e354097a9c7a792f42064c4f78"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbricks_1_1result.html#a702d25e354097a9c7a792f42064c4f78">map</a> (F &amp;&amp;f) const -&gt; <a class="el" href="classbricks_1_1result.html">result</a>&lt; std::invoke_result_t&lt; F, <a class="el" href="classbricks_1_1result.html#a21aebcf1057005dc1fe041cbd5a3cd5c">value_type</a> &gt;, <a class="el" href="classbricks_1_1result.html#a9b8311e26db21f89e2482a499ef13b6c">error_type</a> &gt;</td></tr>
<tr class="memdesc:a702d25e354097a9c7a792f42064c4f78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a <code>result&lt;T, E&gt;</code> to <code>result&lt;U, E&gt;</code> by applying a function to a contained value.  <a href="classbricks_1_1result.html#a702d25e354097a9c7a792f42064c4f78">More...</a><br /></td></tr>
<tr class="separator:a702d25e354097a9c7a792f42064c4f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fa2b6f0ef4f8a46f342e9b8a0a6dca3"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a5fa2b6f0ef4f8a46f342e9b8a0a6dca3"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbricks_1_1result.html#a5fa2b6f0ef4f8a46f342e9b8a0a6dca3">map_error</a> (F &amp;&amp;f) const -&gt; <a class="el" href="classbricks_1_1result.html">result</a>&lt; <a class="el" href="classbricks_1_1result.html#a21aebcf1057005dc1fe041cbd5a3cd5c">value_type</a>, std::invoke_result_t&lt; F, <a class="el" href="classbricks_1_1result.html#a9b8311e26db21f89e2482a499ef13b6c">error_type</a> &gt; &gt;</td></tr>
<tr class="memdesc:a5fa2b6f0ef4f8a46f342e9b8a0a6dca3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps a <code>result&lt;T, E&gt;</code> to <code>result&lt;T, F&gt;</code> by applying a function to a contained error.  <a href="classbricks_1_1result.html#a5fa2b6f0ef4f8a46f342e9b8a0a6dca3">More...</a><br /></td></tr>
<tr class="separator:a5fa2b6f0ef4f8a46f342e9b8a0a6dca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a583d178949677efba703dddf75d679e9"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a583d178949677efba703dddf75d679e9"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbricks_1_1result.html#a583d178949677efba703dddf75d679e9">map_or</a> (std::invoke_result_t&lt; F, <a class="el" href="classbricks_1_1result.html#a21aebcf1057005dc1fe041cbd5a3cd5c">value_type</a> &gt; default_value, F &amp;&amp;f) const -&gt; std::invoke_result_t&lt; F, <a class="el" href="classbricks_1_1result.html#a21aebcf1057005dc1fe041cbd5a3cd5c">value_type</a> &gt;</td></tr>
<tr class="memdesc:a583d178949677efba703dddf75d679e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the provided default (if an error) or applies a function to the contained value.  <a href="classbricks_1_1result.html#a583d178949677efba703dddf75d679e9">More...</a><br /></td></tr>
<tr class="separator:a583d178949677efba703dddf75d679e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad76b4f4b85fbe87803c8dbf5990cfce9"><td class="memTemplParams" colspan="2">template&lt;typename F , typename G &gt; </td></tr>
<tr class="memitem:ad76b4f4b85fbe87803c8dbf5990cfce9"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbricks_1_1result.html#ad76b4f4b85fbe87803c8dbf5990cfce9">map_or_else</a> (G &amp;&amp;default_f, F &amp;&amp;f) const -&gt; std::invoke_result_t&lt; F, <a class="el" href="classbricks_1_1result.html#a21aebcf1057005dc1fe041cbd5a3cd5c">value_type</a> &gt;</td></tr>
<tr class="memdesc:ad76b4f4b85fbe87803c8dbf5990cfce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps the <code>result&lt;T, E&gt;</code> to <code>U</code> by applying fallback function <code>default_f</code> to a contained error, or function <code>f</code> to a contained value.  <a href="classbricks_1_1result.html#ad76b4f4b85fbe87803c8dbf5990cfce9">More...</a><br /></td></tr>
<tr class="separator:ad76b4f4b85fbe87803c8dbf5990cfce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5063aa5121a1aca6913b947cdc17b48"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:ae5063aa5121a1aca6913b947cdc17b48"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbricks_1_1result.html#ae5063aa5121a1aca6913b947cdc17b48">and_instead</a> (const <a class="el" href="classbricks_1_1result.html">result</a>&lt; U, <a class="el" href="classbricks_1_1result.html#a9b8311e26db21f89e2482a499ef13b6c">error_type</a> &gt; &amp;res) const -&gt; <a class="el" href="classbricks_1_1result.html">result</a>&lt; U, <a class="el" href="classbricks_1_1result.html#a9b8311e26db21f89e2482a499ef13b6c">error_type</a> &gt;</td></tr>
<tr class="memdesc:ae5063aa5121a1aca6913b947cdc17b48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>res</code> if the result is a value, otherwise returns the error.  <a href="classbricks_1_1result.html#ae5063aa5121a1aca6913b947cdc17b48">More...</a><br /></td></tr>
<tr class="separator:ae5063aa5121a1aca6913b947cdc17b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78696e85bef890b513722dc828afa523"><td class="memTemplParams" colspan="2">template&lt;typename Op &gt; </td></tr>
<tr class="memitem:a78696e85bef890b513722dc828afa523"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbricks_1_1result.html#a78696e85bef890b513722dc828afa523">and_then</a> (Op &amp;&amp;op) const -&gt; <a class="el" href="classbricks_1_1result.html">result</a>&lt; typename std::invoke_result_t&lt; Op, <a class="el" href="classbricks_1_1result.html#a21aebcf1057005dc1fe041cbd5a3cd5c">value_type</a> &gt;<a class="el" href="classbricks_1_1result.html#a21aebcf1057005dc1fe041cbd5a3cd5c">::value_type</a>, <a class="el" href="classbricks_1_1result.html#a9b8311e26db21f89e2482a499ef13b6c">error_type</a> &gt;</td></tr>
<tr class="memdesc:a78696e85bef890b513722dc828afa523"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls <code>op</code> if the result is a value, otherwise returns the error.  <a href="classbricks_1_1result.html#a78696e85bef890b513722dc828afa523">More...</a><br /></td></tr>
<tr class="separator:a78696e85bef890b513722dc828afa523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d719a837004ecf8f36db40458c9e132"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a4d719a837004ecf8f36db40458c9e132"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbricks_1_1result.html#a4d719a837004ecf8f36db40458c9e132">or_instead</a> (const <a class="el" href="classbricks_1_1result.html">result</a>&lt; <a class="el" href="classbricks_1_1result.html#a21aebcf1057005dc1fe041cbd5a3cd5c">value_type</a>, F &gt; &amp;res) const -&gt; <a class="el" href="classbricks_1_1result.html">result</a>&lt; <a class="el" href="classbricks_1_1result.html#a21aebcf1057005dc1fe041cbd5a3cd5c">value_type</a>, F &gt;</td></tr>
<tr class="memdesc:a4d719a837004ecf8f36db40458c9e132"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>res</code> if the result is an error, otherwise returns the value.  <a href="classbricks_1_1result.html#a4d719a837004ecf8f36db40458c9e132">More...</a><br /></td></tr>
<tr class="separator:a4d719a837004ecf8f36db40458c9e132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a991a1ce1aae6e77000728b2b415ee77e"><td class="memTemplParams" colspan="2">template&lt;typename Op &gt; </td></tr>
<tr class="memitem:a991a1ce1aae6e77000728b2b415ee77e"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbricks_1_1result.html#a991a1ce1aae6e77000728b2b415ee77e">or_else</a> (Op &amp;&amp;op) const -&gt; <a class="el" href="classbricks_1_1result.html">result</a>&lt; <a class="el" href="classbricks_1_1result.html#a21aebcf1057005dc1fe041cbd5a3cd5c">value_type</a>, typename std::invoke_result_t&lt; Op, <a class="el" href="classbricks_1_1result.html#a9b8311e26db21f89e2482a499ef13b6c">error_type</a> &gt;<a class="el" href="classbricks_1_1result.html#a9b8311e26db21f89e2482a499ef13b6c">::error_type</a> &gt;</td></tr>
<tr class="memdesc:a991a1ce1aae6e77000728b2b415ee77e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls <code>op</code> if the result is an error, otherwise returns the value.  <a href="classbricks_1_1result.html#a991a1ce1aae6e77000728b2b415ee77e">More...</a><br /></td></tr>
<tr class="separator:a991a1ce1aae6e77000728b2b415ee77e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9af552af9e7ce8ad3c44fa9817cee4bc"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbricks_1_1result.html#a9af552af9e7ce8ad3c44fa9817cee4bc">operator==</a> (const <a class="el" href="classbricks_1_1result.html">result</a> &amp;other) const noexcept -&gt; bool</td></tr>
<tr class="separator:a9af552af9e7ce8ad3c44fa9817cee4bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1af7abb0572f392eb6a01c7cf07d6b9"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbricks_1_1result.html#aa1af7abb0572f392eb6a01c7cf07d6b9">operator!=</a> (const <a class="el" href="classbricks_1_1result.html">result</a> &amp;other) const noexcept -&gt; bool</td></tr>
<tr class="separator:aa1af7abb0572f392eb6a01c7cf07d6b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a0a1531f1770d4b75bc44f637c56328cd"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a0a1531f1770d4b75bc44f637c56328cd"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbricks_1_1result.html#a0a1531f1770d4b75bc44f637c56328cd">from_try_or</a> (F &amp;&amp;f, <a class="el" href="classbricks_1_1result.html#a9b8311e26db21f89e2482a499ef13b6c">error_type</a> error_value) noexcept(std::is_nothrow_constructible_v&lt; <a class="el" href="namespacebricks.html#a56141134ef4783cc27e2f3e970dbedf5">err</a>&lt; E &gt;, <a class="el" href="classbricks_1_1result.html#a9b8311e26db21f89e2482a499ef13b6c">error_type</a> &gt;) -&gt; <a class="el" href="classbricks_1_1result.html">result</a></td></tr>
<tr class="memdesc:a0a1531f1770d4b75bc44f637c56328cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new result object from an operation that might throw.  <a href="classbricks_1_1result.html#a0a1531f1770d4b75bc44f637c56328cd">More...</a><br /></td></tr>
<tr class="separator:a0a1531f1770d4b75bc44f637c56328cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01a671e3420714fc7d389202aa0f4515"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a01a671e3420714fc7d389202aa0f4515"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbricks_1_1result.html#a01a671e3420714fc7d389202aa0f4515">from_try_or_default</a> (F &amp;&amp;f) noexcept(std::is_nothrow_invocable_v&lt; decltype(<a class="el" href="classbricks_1_1result.html">result</a>&lt; T, E &gt;<a class="el" href="classbricks_1_1result.html#a0a1531f1770d4b75bc44f637c56328cd">::from_try_or</a>&lt; F &gt;)&gt; &amp;&amp;std::is_nothrow_constructible_v&lt; <a class="el" href="classbricks_1_1result.html#a9b8311e26db21f89e2482a499ef13b6c">error_type</a> &gt;) -&gt; <a class="el" href="classbricks_1_1result.html">result</a></td></tr>
<tr class="memdesc:a01a671e3420714fc7d389202aa0f4515"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new result object from an operation that might throw.  <a href="classbricks_1_1result.html#a01a671e3420714fc7d389202aa0f4515">More...</a><br /></td></tr>
<tr class="separator:a01a671e3420714fc7d389202aa0f4515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ec1bb36b6a4e4b47026380e8fd07340"><td class="memTemplParams" colspan="2">template&lt;typename F , typename OnError &gt; </td></tr>
<tr class="memitem:a7ec1bb36b6a4e4b47026380e8fd07340"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbricks_1_1result.html#a7ec1bb36b6a4e4b47026380e8fd07340">from_try_or_else</a> (F &amp;&amp;f, OnError &amp;&amp;on_error) noexcept(std::is_nothrow_invocable_v&lt; OnError &gt; &amp;&amp;std::is_nothrow_constructible_v&lt; <a class="el" href="classbricks_1_1result.html">result</a>&lt; T, E &gt;, std::invoke_result_t&lt; OnError &gt; &gt;) -&gt; <a class="el" href="classbricks_1_1result.html">result</a></td></tr>
<tr class="memdesc:a7ec1bb36b6a4e4b47026380e8fd07340"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new result from an operation that might throw or the result of a function.  <a href="classbricks_1_1result.html#a7ec1bb36b6a4e4b47026380e8fd07340">More...</a><br /></td></tr>
<tr class="separator:a7ec1bb36b6a4e4b47026380e8fd07340"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:aa8eaf1c31aa744d327f502c63cc6881e"><td class="memItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbricks_1_1result.html#aa8eaf1c31aa744d327f502c63cc6881e">std::hash</a> (const <a class="el" href="classbricks_1_1result.html">result</a> &amp;r) const noexcept -&gt; std::size_t</td></tr>
<tr class="separator:aa8eaf1c31aa744d327f502c63cc6881e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T, typename E&gt;<br />
class bricks::result&lt; T, E &gt;</div><p >A class to represent the result of an operation. </p>
<p >This class is used to represent the result of an operation, which can fail. It can either be a value or an error. It is similar to the <code>std::expected</code> proposal or the rust <code>Result</code> type.</p>
<p >The value type and the error type can be different. If they are the same, one can use the <code>ok&lt;T&gt;</code> and <code>err&lt;E&gt;</code> types to construct and assign the result.</p>
<p >Example: </p><div class="fragment"><div class="line">  <span class="comment">// Division can fail by either dividing by zero or having a non zero remainder</span></div>
<div class="line">  <span class="keyword">auto</span> divide = [](<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b) -&gt; <a class="code hl_class" href="classbricks_1_1result.html">bricks::result&lt;int, std::invalid_argument&gt;</a> {</div>
<div class="line">    <span class="keywordflow">if</span> (b == 0) {</div>
<div class="line">      <span class="keywordflow">return</span> {std::invalid_argument{<span class="stringliteral">&quot;division by zero&quot;</span>}};</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (a % b != 0) {</div>
<div class="line">      <span class="keywordflow">return</span> {std::invalid_argument{<span class="stringliteral">&quot;non zero remainder&quot;</span>}};</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">return</span> {a / b};</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// By using the `bricks::result` type, you can avoid throwing exceptions for potential failures</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> res = divide(42, 2);</div>
<div class="line">  <span class="keywordflow">if</span> (res.is_value()) {</div>
<div class="line">    INFO(<span class="stringliteral">&quot;The result is &quot;</span>, res.unwrap());</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    INFO(<span class="stringliteral">&quot;The error is: &quot;</span>, res.unwrap_error().what());</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// It can also be used to easily chain function calls together in a functional style</span></div>
<div class="line">  <span class="keyword">auto</span> scale_by_two = [](<span class="keywordtype">int</span> i) -&gt; <a class="code hl_class" href="classbricks_1_1result.html">bricks::result&lt;int, std::invalid_argument&gt;</a> {</div>
<div class="line">    <span class="keywordflow">if</span> (i == 0) <span class="keywordflow">return</span> {std::invalid_argument{<span class="stringliteral">&quot;scaling zero is not supported&quot;</span>}};</div>
<div class="line">    <span class="keywordflow">return</span> {i * 2};</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> scaled_and_stringified = divide(42, 2)</div>
<div class="line">                                          .<a class="code hl_function" href="classbricks_1_1result.html#a78696e85bef890b513722dc828afa523">and_then</a>(scale_by_two)</div>
<div class="line">                                          .map([](<span class="keywordtype">int</span> i) { <span class="keywordflow">return</span> std::to_string(i); })</div>
<div class="line">                                          .<a class="code hl_function" href="classbricks_1_1result.html#adc5b09e34960d2afbcae03264a65f595">unwrap_or</a>(<span class="stringliteral">&quot;something went wrong&quot;</span>);</div>
<div class="line"> </div>
<div class="line">  CHECK(scaled_and_stringified == <span class="stringliteral">&quot;42&quot;</span>);</div>
<div class="ttc" id="aclassbricks_1_1result_html"><div class="ttname"><a href="classbricks_1_1result.html">bricks::result</a></div><div class="ttdoc">A class to represent the result of an operation.</div><div class="ttdef"><b>Definition:</b> result.hpp:92</div></div>
<div class="ttc" id="aclassbricks_1_1result_html_a78696e85bef890b513722dc828afa523"><div class="ttname"><a href="classbricks_1_1result.html#a78696e85bef890b513722dc828afa523">bricks::result::and_then</a></div><div class="ttdeci">constexpr auto and_then(Op &amp;&amp;op) const -&gt; result&lt; typename std::invoke_result_t&lt; Op, value_type &gt;::value_type, error_type &gt;</div><div class="ttdoc">Calls op if the result is a value, otherwise returns the error.</div><div class="ttdef"><b>Definition:</b> result.hpp:539</div></div>
<div class="ttc" id="aclassbricks_1_1result_html_adc5b09e34960d2afbcae03264a65f595"><div class="ttname"><a href="classbricks_1_1result.html#adc5b09e34960d2afbcae03264a65f595">bricks::result::unwrap_or</a></div><div class="ttdeci">constexpr auto unwrap_or(value_type default_value) const noexcept -&gt; value_type</div><div class="ttdoc">Returns the value of the result.</div><div class="ttdef"><b>Definition:</b> result.hpp:370</div></div>
</div><!-- fragment --> </div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a9b8311e26db21f89e2482a499ef13b6c" name="a9b8311e26db21f89e2482a499ef13b6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b8311e26db21f89e2482a499ef13b6c">&#9670;&#160;</a></span>error_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbricks_1_1result.html">bricks::result</a>&lt; T, E &gt;::error_type =  E</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The error type of the result. </p>

</div>
</div>
<a id="a21aebcf1057005dc1fe041cbd5a3cd5c" name="a21aebcf1057005dc1fe041cbd5a3cd5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21aebcf1057005dc1fe041cbd5a3cd5c">&#9670;&#160;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classbricks_1_1result.html">bricks::result</a>&lt; T, E &gt;::value_type =  T</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The value type of the result. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7ccc36f39e6dd02c9ecbbabe4960c220" name="a7ccc36f39e6dd02c9ecbbabe4960c220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ccc36f39e6dd02c9ecbbabe4960c220">&#9670;&#160;</a></span>result() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbricks_1_1result.html">bricks::result</a>&lt; T, E &gt;::result </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aff8d1bec8d5a22f1224ab2731827222a" name="aff8d1bec8d5a22f1224ab2731827222a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff8d1bec8d5a22f1224ab2731827222a">&#9670;&#160;</a></span>result() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbricks_1_1result.html">bricks::result</a>&lt; T, E &gt;::result </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbricks_1_1result.html">result</a>&lt; T, E &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae355663cd439ad0f1aef1ffd0336bc82" name="ae355663cd439ad0f1aef1ffd0336bc82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae355663cd439ad0f1aef1ffd0336bc82">&#9670;&#160;</a></span>result() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbricks_1_1result.html">bricks::result</a>&lt; T, E &gt;::result </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbricks_1_1result.html">result</a>&lt; T, E &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a04f4c2252597e0ea52ec5d0324165207" name="a04f4c2252597e0ea52ec5d0324165207"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04f4c2252597e0ea52ec5d0324165207">&#9670;&#160;</a></span>~result()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbricks_1_1result.html">bricks::result</a>&lt; T, E &gt;::~<a class="el" href="classbricks_1_1result.html">result</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa5d62d4703512f55841c95708a807f04" name="aa5d62d4703512f55841c95708a807f04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5d62d4703512f55841c95708a807f04">&#9670;&#160;</a></span>result() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<div class="memtemplate">
template&lt;typename U , typename std::enable_if_t&lt; std::is_same_v&lt; U, <a class="el" href="namespacebricks.html#a19b2ba7d93c79fd196404d3fc50eac4f">ok</a>&lt; T &gt; &gt;||std::is_same_v&lt; U, <a class="el" href="namespacebricks.html#a56141134ef4783cc27e2f3e970dbedf5">err</a>&lt; E &gt; &gt;, bool &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classbricks_1_1result.html">bricks::result</a>&lt; T, E &gt;::result </td>
          <td>(</td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new result object from a value. </p>
<p >If the value and error types are the same, one must use the <code>ok&lt;T&gt;</code> and <code>err&lt;E&gt;</code> types to construct the result. Otherwise the value type must be convertible to the value type of the result. And the error type must be convertible to the error type of the result.</p>
<p >Example: </p><div class="fragment"><div class="line">    <span class="comment">// With non equal value and error types you can easily construct a result</span></div>
<div class="line">    <a class="code hl_class" href="classbricks_1_1result.html">bricks::result&lt;int, std::string&gt;</a> res1{42};</div>
<div class="line">    <a class="code hl_class" href="classbricks_1_1result.html">bricks::result&lt;int, std::string&gt;</a> res2{<span class="stringliteral">&quot;error&quot;</span>};</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// With equal value and error types you have to use the ok and err types</span></div>
<div class="line">    <a class="code hl_class" href="classbricks_1_1result.html">bricks::result&lt;int, int&gt;</a> res3{ok&lt;int&gt;{42}};</div>
<div class="line">    <a class="code hl_class" href="classbricks_1_1result.html">bricks::result&lt;int, int&gt;</a> res4{err&lt;int&gt;{0}};</div>
<div class="line">    <span class="comment">// bricks::result&lt;int, int&gt; res5{42}; // error</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The value to construct the result from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afae47e70bcb7b32ba38cbceb2ed0d4fb" name="afae47e70bcb7b32ba38cbceb2ed0d4fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afae47e70bcb7b32ba38cbceb2ed0d4fb">&#9670;&#160;</a></span>result() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<div class="memtemplate">
template&lt;typename U  = T, typename std::enable_if_t&lt;!std::is_same_v&lt; U, E &gt;, bool &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classbricks_1_1result.html">bricks::result</a>&lt; T, E &gt;::result </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbricks_1_1result.html#a21aebcf1057005dc1fe041cbd5a3cd5c">value_type</a>&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac0c2d611cae957befd497ccace779a94" name="ac0c2d611cae957befd497ccace779a94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0c2d611cae957befd497ccace779a94">&#9670;&#160;</a></span>result() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<div class="memtemplate">
template&lt;typename U  = E, typename std::enable_if_t&lt;!std::is_same_v&lt; T, U &gt;, bool &gt;  = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classbricks_1_1result.html">bricks::result</a>&lt; T, E &gt;::result </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbricks_1_1result.html#a9b8311e26db21f89e2482a499ef13b6c">error_type</a>&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae5063aa5121a1aca6913b947cdc17b48" name="ae5063aa5121a1aca6913b947cdc17b48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5063aa5121a1aca6913b947cdc17b48">&#9670;&#160;</a></span>and_instead()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classbricks_1_1result.html">bricks::result</a>&lt; T, E &gt;::and_instead </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbricks_1_1result.html">result</a>&lt; U, <a class="el" href="classbricks_1_1result.html#a9b8311e26db21f89e2482a499ef13b6c">error_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td> const -&gt; <a class="el" href="classbricks_1_1result.html">result</a>&lt;U, <a class="el" href="classbricks_1_1result.html#a9b8311e26db21f89e2482a499ef13b6c">error_type</a>&gt;
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>res</code> if the result is a value, otherwise returns the error. </p>
<p >This function can be used for control flow based on result values.</p>
<p >Example: </p><div class="fragment"><div class="line">    <span class="keyword">auto</span> parse_int = [](<span class="keyword">const</span> std::string&amp; s) -&gt; <a class="code hl_class" href="classbricks_1_1result.html">bricks::result&lt;int, std::invalid_argument&gt;</a> {</div>
<div class="line">      <span class="keywordflow">try</span> {</div>
<div class="line">        <span class="keywordflow">return</span> {std::stoi(s)};</div>
<div class="line">      } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::invalid_argument&amp; e) {</div>
<div class="line">        <span class="keywordflow">return</span> {e};</div>
<div class="line">      }</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classbricks_1_1result.html">bricks::result&lt;std::string, std::invalid_argument&gt;</a> res{<span class="stringliteral">&quot;42&quot;</span>};</div>
<div class="line">    CHECK(res.and_then(parse_int)  <span class="comment">// result&lt;int, std::invalid_argument&gt;</span></div>
<div class="line">              .and_instead(result&lt;int, std::invalid_argument&gt;{1})</div>
<div class="line">              .unwrap() == 1);</div>
<div class="line"> </div>
<div class="line">    res = <span class="stringliteral">&quot;not a number&quot;</span>;</div>
<div class="line">    CHECK(res.and_then(parse_int)  <span class="comment">// result&lt;int, std::invalid_argument&gt;</span></div>
<div class="line">              .and_instead(result&lt;int, std::invalid_argument&gt;{1})</div>
<div class="line">              .is_error());</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>The result to return if the result is a value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result&lt;U, error_type&gt; The result of the function. </dd></dl>

</div>
</div>
<a id="a78696e85bef890b513722dc828afa523" name="a78696e85bef890b513722dc828afa523"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78696e85bef890b513722dc828afa523">&#9670;&#160;</a></span>and_then()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<div class="memtemplate">
template&lt;typename Op &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classbricks_1_1result.html">bricks::result</a>&lt; T, E &gt;::and_then </td>
          <td>(</td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const -&gt; <a class="el" href="classbricks_1_1result.html">result</a>&lt;typename std::invoke_result_t&lt;Op, <a class="el" href="classbricks_1_1result.html#a21aebcf1057005dc1fe041cbd5a3cd5c">value_type</a>&gt;<a class="el" href="classbricks_1_1result.html#a21aebcf1057005dc1fe041cbd5a3cd5c">::value_type</a>, <a class="el" href="classbricks_1_1result.html#a9b8311e26db21f89e2482a499ef13b6c">error_type</a>&gt;
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls <code>op</code> if the result is a value, otherwise returns the error. </p>
<p >This function can be used for control flow based on result values.</p>
<p >Example: </p><div class="fragment"><div class="line">    <span class="keyword">auto</span> divide = [](<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b) -&gt; <a class="code hl_class" href="classbricks_1_1result.html">bricks::result&lt;int, std::string&gt;</a> {</div>
<div class="line">      <span class="keywordflow">if</span> (b == 0) {</div>
<div class="line">        <span class="keywordflow">return</span> {<span class="stringliteral">&quot;division by zero&quot;</span>};</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">return</span> {a / b};</div>
<div class="line">    };</div>
<div class="line">    <span class="keyword">auto</span> scale = [](<span class="keywordtype">int</span> a) -&gt; <a class="code hl_class" href="classbricks_1_1result.html">bricks::result&lt;int, std::string&gt;</a> {</div>
<div class="line">      <span class="keywordflow">if</span> (a == 0) {</div>
<div class="line">        <span class="keywordflow">return</span> {<span class="stringliteral">&quot;scaling zero is not allowed&quot;</span>};</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">return</span> {a * 2};</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classbricks_1_1result.html">bricks::result&lt;int, std::string&gt;</a> res{42};</div>
<div class="line">    CHECK(res.and_then([&amp;](<span class="keywordtype">int</span> a) { return divide(a, 2); })  <span class="comment">// result&lt;int, std::string&gt;</span></div>
<div class="line">              .and_then(scale)                               <span class="comment">// result&lt;int, std::string&gt;</span></div>
<div class="line">              .unwrap() == 42);</div>
<div class="line"> </div>
<div class="line">    res = 0;</div>
<div class="line">    CHECK(res.and_then([&amp;](<span class="keywordtype">int</span> a) { return divide(a, 2); })  <span class="comment">// result&lt;int, std::string&gt;</span></div>
<div class="line">              .and_then(scale)                               <span class="comment">// result&lt;int, std::string&gt;</span></div>
<div class="line">              .unwrap_error() == <span class="stringliteral">&quot;scaling zero is not allowed&quot;</span>);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operation to perform on the value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result&lt;U, error_type&gt; </dd></dl>

</div>
</div>
<a id="a92bf3bf0dfe7b1797589fe498dc98b3c" name="a92bf3bf0dfe7b1797589fe498dc98b3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92bf3bf0dfe7b1797589fe498dc98b3c">&#9670;&#160;</a></span>expect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classbricks_1_1result.html">bricks::result</a>&lt; T, E &gt;::expect </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td> const -&gt; <a class="el" href="classbricks_1_1result.html#a21aebcf1057005dc1fe041cbd5a3cd5c">value_type</a>
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of the result. </p>
<p >Throws a <code><a class="el" href="classbricks_1_1bad__result__access.html" title="This is the type of the error thrown when accessing a bad result.">bad_result_access</a></code> if the result is an error, with the provided message.</p>
<p >Example: </p><div class="fragment"><div class="line">    <a class="code hl_class" href="classbricks_1_1result.html">bricks::result&lt;int, std::string&gt;</a> res{<span class="stringliteral">&quot;error&quot;</span>};</div>
<div class="line">    CHECK_THROWS_WITH_AS([[maybe_unused]] <span class="keyword">const</span> <span class="keyword">auto</span> ret = res.expect(<span class="stringliteral">&quot;The result is an error.&quot;</span>),</div>
<div class="line">                         <span class="stringliteral">&quot;The result is an error.&quot;</span>, <a class="code hl_class" href="classbricks_1_1bad__result__access.html">bricks::bad_result_access</a>);</div>
<div class="ttc" id="aclassbricks_1_1bad__result__access_html"><div class="ttname"><a href="classbricks_1_1bad__result__access.html">bricks::bad_result_access</a></div><div class="ttdoc">This is the type of the error thrown when accessing a bad result.</div><div class="ttdef"><b>Definition:</b> result.hpp:24</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>The message to use in the exception. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value_type The value of the result. </dd></dl>

</div>
</div>
<a id="a8d75a95f5125b0535eca50e278fb2b6f" name="a8d75a95f5125b0535eca50e278fb2b6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d75a95f5125b0535eca50e278fb2b6f">&#9670;&#160;</a></span>expect_error()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classbricks_1_1result.html">bricks::result</a>&lt; T, E &gt;::expect_error </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td> const -&gt; <a class="el" href="classbricks_1_1result.html#a9b8311e26db21f89e2482a499ef13b6c">error_type</a>
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the error of the result. </p>
<p >Throws a <code><a class="el" href="classbricks_1_1bad__result__access.html" title="This is the type of the error thrown when accessing a bad result.">bad_result_access</a></code> if the result is a value, with the provided message.</p>
<p >Example: </p><div class="fragment"><div class="line">    <a class="code hl_class" href="classbricks_1_1result.html">bricks::result&lt;int, std::string&gt;</a> res{42};</div>
<div class="line">    CHECK_THROWS_WITH_AS(</div>
<div class="line">        [[maybe_unused]] <span class="keyword">const</span> <span class="keyword">auto</span> ret = res.expect_error(<span class="stringliteral">&quot;The result is a value.&quot;</span>),</div>
<div class="line">        <span class="stringliteral">&quot;The result is a value.&quot;</span>, <a class="code hl_class" href="classbricks_1_1bad__result__access.html">bricks::bad_result_access</a>);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>The message to use in the exception. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>error_type The error of the result. </dd></dl>

</div>
</div>
<a id="a0a1531f1770d4b75bc44f637c56328cd" name="a0a1531f1770d4b75bc44f637c56328cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a1531f1770d4b75bc44f637c56328cd">&#9670;&#160;</a></span>from_try_or()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto <a class="el" href="classbricks_1_1result.html">bricks::result</a>&lt; T, E &gt;::from_try_or </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbricks_1_1result.html#a9b8311e26db21f89e2482a499ef13b6c">error_type</a>&#160;</td>
          <td class="paramname"><em>error_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classbricks_1_1result.html">result</a>
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new result object from an operation that might throw. </p>
<p >Returns the result of calling function <code>f</code> or the provided error value if the operation throws. This function is useful to convert functions that might throw to functions that return a result.</p>
<p >Example: </p><div class="fragment"><div class="line">    <span class="comment">// You can use the `from_try_or` function to convert a function that can throw to a function</span></div>
<div class="line">    <span class="comment">// that returns a result</span></div>
<div class="line">    <span class="keyword">auto</span> divide = [](<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b) {</div>
<div class="line">      <span class="keywordflow">if</span> (b == 0) {</div>
<div class="line">        <span class="keywordflow">throw</span> std::invalid_argument{<span class="stringliteral">&quot;division by zero&quot;</span>};</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">return</span> a / b;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">enum class</span> error { division_by_zero, non_zero_remainder };</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> res = <a class="code hl_function" href="classbricks_1_1result.html#a0a1531f1770d4b75bc44f637c56328cd">result&lt;int, error&gt;::from_try_or</a>([divide]() { <span class="keywordflow">return</span> divide(42, 2); },</div>
<div class="line">                                                     error::division_by_zero);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (res.is_value()) {</div>
<div class="line">      INFO(<span class="stringliteral">&quot;The result is &quot;</span>, res.unwrap());</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      INFO(<span class="stringliteral">&quot;The error is: &quot;</span>, res.unwrap_error());</div>
<div class="line">    }</div>
<div class="ttc" id="aclassbricks_1_1result_html_a0a1531f1770d4b75bc44f637c56328cd"><div class="ttname"><a href="classbricks_1_1result.html#a0a1531f1770d4b75bc44f637c56328cd">bricks::result::from_try_or</a></div><div class="ttdeci">static auto from_try_or(F &amp;&amp;f, error_type error_value) noexcept(std::is_nothrow_constructible_v&lt; err&lt; E &gt;, error_type &gt;) -&gt; result</div><div class="ttdoc">Construct a new result object from an operation that might throw.</div><div class="ttdef"><b>Definition:</b> result.hpp:162</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The operation to try. </td></tr>
    <tr><td class="paramname">error_value</td><td>The error value to return if the operation throws. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result&lt;T, E&gt; The result of the operation. </dd></dl>

</div>
</div>
<a id="a01a671e3420714fc7d389202aa0f4515" name="a01a671e3420714fc7d389202aa0f4515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01a671e3420714fc7d389202aa0f4515">&#9670;&#160;</a></span>from_try_or_default()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto <a class="el" href="classbricks_1_1result.html">bricks::result</a>&lt; T, E &gt;::from_try_or_default </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classbricks_1_1result.html">result</a>
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new result object from an operation that might throw. </p>
<p >Returns the result of calling function <code>f</code> or a default constructed error value if <code>f</code> throws. This function is useful to convert functions that might throw to functions that return a result.</p>
<p >Example: </p><div class="fragment"><div class="line">    <span class="comment">// You can use the `from_try_or_default` function to convert a function that can throw to a</span></div>
<div class="line">    <span class="comment">// function that returns a result</span></div>
<div class="line">    <span class="keyword">auto</span> divide = [](<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b) {</div>
<div class="line">      <span class="keywordflow">if</span> (b == 0) {</div>
<div class="line">        <span class="keywordflow">throw</span> std::invalid_argument{<span class="stringliteral">&quot;division by zero&quot;</span>};</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">return</span> a / b;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> res = <a class="code hl_function" href="classbricks_1_1result.html#a01a671e3420714fc7d389202aa0f4515">result&lt;int, float&gt;::from_try_or_default</a>([divide]() { <span class="keywordflow">return</span> divide(42, 2); });</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (res.is_value()) {</div>
<div class="line">      INFO(<span class="stringliteral">&quot;The result is &quot;</span>, res.unwrap());</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      INFO(<span class="stringliteral">&quot;The error is: &quot;</span>, res.unwrap_error());  <span class="comment">// 0</span></div>
<div class="line">    }</div>
<div class="ttc" id="aclassbricks_1_1result_html_a01a671e3420714fc7d389202aa0f4515"><div class="ttname"><a href="classbricks_1_1result.html#a01a671e3420714fc7d389202aa0f4515">bricks::result::from_try_or_default</a></div><div class="ttdeci">static auto from_try_or_default(F &amp;&amp;f) noexcept(std::is_nothrow_invocable_v&lt; decltype(result&lt; T, E &gt;::from_try_or&lt; F &gt;)&gt; &amp;&amp;std::is_nothrow_constructible_v&lt; error_type &gt;) -&gt; result</div><div class="ttdoc">Construct a new result object from an operation that might throw.</div><div class="ttdef"><b>Definition:</b> result.hpp:190</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The operation to try. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result&lt;T, E&gt; The result of the operation. </dd></dl>

</div>
</div>
<a id="a7ec1bb36b6a4e4b47026380e8fd07340" name="a7ec1bb36b6a4e4b47026380e8fd07340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ec1bb36b6a4e4b47026380e8fd07340">&#9670;&#160;</a></span>from_try_or_else()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<div class="memtemplate">
template&lt;typename F , typename OnError &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto <a class="el" href="classbricks_1_1result.html">bricks::result</a>&lt; T, E &gt;::from_try_or_else </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OnError &amp;&amp;&#160;</td>
          <td class="paramname"><em>on_error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classbricks_1_1result.html">result</a>
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new result from an operation that might throw or the result of a function. </p>
<p >Returns the result of calling <code>f</code> if it doesn't throw. If the <code>f</code> throws, returns the result of the provided <code>on_error</code> function.</p>
<p >Example: </p><div class="fragment"><div class="line">    <span class="comment">// You can use the `from_try_or_else` function to convert a function that can throw to a</span></div>
<div class="line">    <span class="comment">// function that returns a result</span></div>
<div class="line">    <span class="keyword">auto</span> divide = [](<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b) {</div>
<div class="line">      <span class="keywordflow">if</span> (b == 0) {</div>
<div class="line">        <span class="keywordflow">throw</span> std::invalid_argument{<span class="stringliteral">&quot;division by zero&quot;</span>};</div>
<div class="line">      }</div>
<div class="line">      <span class="keywordflow">return</span> a / b;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">enum class</span> error { division };</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> res = <a class="code hl_function" href="classbricks_1_1result.html#a7ec1bb36b6a4e4b47026380e8fd07340">result&lt;int, error&gt;::from_try_or_else</a>(</div>
<div class="line">        [divide]() { <span class="keywordflow">return</span> divide(42, 2); }, []() <span class="keyword">noexcept</span> { <span class="keywordflow">return</span> error::division; });</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (res.is_value()) {</div>
<div class="line">      INFO(<span class="stringliteral">&quot;The result is &quot;</span>, res.unwrap());</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      INFO(<span class="stringliteral">&quot;The error is: &quot;</span>, res.unwrap_error());</div>
<div class="line">    }</div>
<div class="ttc" id="aclassbricks_1_1result_html_a7ec1bb36b6a4e4b47026380e8fd07340"><div class="ttname"><a href="classbricks_1_1result.html#a7ec1bb36b6a4e4b47026380e8fd07340">bricks::result::from_try_or_else</a></div><div class="ttdeci">static auto from_try_or_else(F &amp;&amp;f, OnError &amp;&amp;on_error) noexcept(std::is_nothrow_invocable_v&lt; OnError &gt; &amp;&amp;std::is_nothrow_constructible_v&lt; result&lt; T, E &gt;, std::invoke_result_t&lt; OnError &gt; &gt;) -&gt; result</div><div class="ttdoc">Construct a new result from an operation that might throw or the result of a function.</div><div class="ttdef"><b>Definition:</b> result.hpp:215</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The operation to try. </td></tr>
    <tr><td class="paramname">on_error</td><td>The function to call if <code>f</code> throws. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result The result of the operation. </dd></dl>

</div>
</div>
<a id="a86cdaac204681255c6c48ac3bc753b7f" name="a86cdaac204681255c6c48ac3bc753b7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86cdaac204681255c6c48ac3bc753b7f">&#9670;&#160;</a></span>is_error()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classbricks_1_1result.html">bricks::result</a>&lt; T, E &gt;::is_error </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bool
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the result is an error. </p>
<p >Example: </p><div class="fragment"><div class="line">    <a class="code hl_class" href="classbricks_1_1result.html">result&lt;int, std::string&gt;</a> res{<span class="stringliteral">&quot;error&quot;</span>};</div>
<div class="line">    <span class="keywordflow">if</span> (res.is_error()) {</div>
<div class="line">      <span class="comment">// do something with the error</span></div>
<div class="line">    }</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>true If the result is an error. </dd>
<dd>
false If the result is a value. </dd></dl>

</div>
</div>
<a id="a208708da81a03492f0c0186adbbad67e" name="a208708da81a03492f0c0186adbbad67e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a208708da81a03492f0c0186adbbad67e">&#9670;&#160;</a></span>is_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classbricks_1_1result.html">bricks::result</a>&lt; T, E &gt;::is_value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; bool
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the result is a value. </p>
<p >Example: </p><div class="fragment"><div class="line">    <a class="code hl_class" href="classbricks_1_1result.html">result&lt;int, std::string&gt;</a> res{42};</div>
<div class="line">    <span class="keywordflow">if</span> (res.is_value()) {</div>
<div class="line">      <span class="comment">// do something with the value</span></div>
<div class="line">    }</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>true If the result is a value. </dd>
<dd>
false If the result is an error. </dd></dl>

</div>
</div>
<a id="a702d25e354097a9c7a792f42064c4f78" name="a702d25e354097a9c7a792f42064c4f78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a702d25e354097a9c7a792f42064c4f78">&#9670;&#160;</a></span>map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classbricks_1_1result.html">bricks::result</a>&lt; T, E &gt;::map </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const -&gt; <a class="el" href="classbricks_1_1result.html">result</a>&lt;std::invoke_result_t&lt;F, <a class="el" href="classbricks_1_1result.html#a21aebcf1057005dc1fe041cbd5a3cd5c">value_type</a>&gt;, <a class="el" href="classbricks_1_1result.html#a9b8311e26db21f89e2482a499ef13b6c">error_type</a>&gt;
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps a <code>result&lt;T, E&gt;</code> to <code>result&lt;U, E&gt;</code> by applying a function to a contained value. </p>
<p >This function can be used to compose the results of two functions.</p>
<p >Example: </p><div class="fragment"><div class="line">    <span class="keyword">auto</span> parse_int = [](<span class="keyword">const</span> std::string&amp; s) -&gt; <a class="code hl_class" href="classbricks_1_1result.html">bricks::result&lt;int, std::invalid_argument&gt;</a> {</div>
<div class="line">      <span class="keywordflow">try</span> {</div>
<div class="line">        <span class="keywordflow">return</span> {std::stoi(s)};</div>
<div class="line">      } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::invalid_argument&amp; e) {</div>
<div class="line">        <span class="keywordflow">return</span> {e};</div>
<div class="line">      }</div>
<div class="line">    };</div>
<div class="line">    <span class="keyword">auto</span> <a class="code hl_function" href="namespacebricks.html#ab48b3432f6b25c66c5669c3b5cdb6114">to_string</a> = [](<span class="keywordtype">int</span> i) { <span class="keywordflow">return</span> std::to_string(i); };</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classbricks_1_1result.html">bricks::result&lt;std::string, std::invalid_argument&gt;</a> res{<span class="stringliteral">&quot;42&quot;</span>};</div>
<div class="line">    CHECK(res.and_then(parse_int).map(<a class="code hl_function" href="namespacebricks.html#ab48b3432f6b25c66c5669c3b5cdb6114">to_string</a>).unwrap() == <span class="stringliteral">&quot;42&quot;</span>);</div>
<div class="line"> </div>
<div class="line">    res = <span class="stringliteral">&quot;not a number&quot;</span>;</div>
<div class="line">    CHECK(res.and_then(parse_int).map(<a class="code hl_function" href="namespacebricks.html#ab48b3432f6b25c66c5669c3b5cdb6114">to_string</a>).is_error());</div>
<div class="ttc" id="anamespacebricks_html_ab48b3432f6b25c66c5669c3b5cdb6114"><div class="ttname"><a href="namespacebricks.html#ab48b3432f6b25c66c5669c3b5cdb6114">bricks::to_string</a></div><div class="ttdeci">auto to_string(const T &amp;value, std::string &amp;str) noexcept -&gt; bool</div><div class="ttdoc">Exceptionlessly convert a number to a string.</div><div class="ttdef"><b>Definition:</b> charconv.hpp:28</div></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>The type of the function to apply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to apply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result&lt;std::invoke_result_t&lt;F, value_type&gt;, error_type&gt; The result of the function. </dd></dl>

</div>
</div>
<a id="a5fa2b6f0ef4f8a46f342e9b8a0a6dca3" name="a5fa2b6f0ef4f8a46f342e9b8a0a6dca3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fa2b6f0ef4f8a46f342e9b8a0a6dca3">&#9670;&#160;</a></span>map_error()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classbricks_1_1result.html">bricks::result</a>&lt; T, E &gt;::map_error </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const -&gt; <a class="el" href="classbricks_1_1result.html">result</a>&lt;<a class="el" href="classbricks_1_1result.html#a21aebcf1057005dc1fe041cbd5a3cd5c">value_type</a>, std::invoke_result_t&lt;F, <a class="el" href="classbricks_1_1result.html#a9b8311e26db21f89e2482a499ef13b6c">error_type</a>&gt;&gt;
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps a <code>result&lt;T, E&gt;</code> to <code>result&lt;T, F&gt;</code> by applying a function to a contained error. </p>
<p >This function can be used to pass through a successful result while handling an error.</p>
<p >Example: </p><div class="fragment"><div class="line">    <span class="keyword">auto</span> parse_int = [](<span class="keyword">const</span> std::string&amp; s) -&gt; <a class="code hl_class" href="classbricks_1_1result.html">bricks::result&lt;int, std::invalid_argument&gt;</a> {</div>
<div class="line">      <span class="keywordflow">try</span> {</div>
<div class="line">        <span class="keywordflow">return</span> {std::stoi(s)};</div>
<div class="line">      } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::invalid_argument&amp;) {</div>
<div class="line">        <span class="keywordflow">return</span> {std::invalid_argument{<span class="stringliteral">&quot;invalid argument&quot;</span>}};</div>
<div class="line">      }</div>
<div class="line">    };</div>
<div class="line">    <span class="keyword">auto</span> error_to_string = [](<span class="keyword">const</span> std::invalid_argument&amp; e) -&gt; std::string { <span class="keywordflow">return</span> e.what(); };</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classbricks_1_1result.html">bricks::result&lt;std::string, std::invalid_argument&gt;</a> res{<span class="stringliteral">&quot;42&quot;</span>};</div>
<div class="line">    CHECK(res.and_then(parse_int).map_error(error_to_string).unwrap() == 42);</div>
<div class="line"> </div>
<div class="line">    res = <span class="stringliteral">&quot;invalid&quot;</span>;</div>
<div class="line">    CHECK(res.and_then(parse_int).map_error(error_to_string).unwrap_error() == <span class="stringliteral">&quot;invalid argument&quot;</span>);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td>The type of the function to apply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to apply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classbricks_1_1result.html#a7ccc36f39e6dd02c9ecbbabe4960c220">result&lt;value_type, std::invoke_result_t&lt;F, error_type&gt;&gt;</a> The result of the function. </dd></dl>

</div>
</div>
<a id="a583d178949677efba703dddf75d679e9" name="a583d178949677efba703dddf75d679e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a583d178949677efba703dddf75d679e9">&#9670;&#160;</a></span>map_or()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classbricks_1_1result.html">bricks::result</a>&lt; T, E &gt;::map_or </td>
          <td>(</td>
          <td class="paramtype">std::invoke_result_t&lt; F, <a class="el" href="classbricks_1_1result.html#a21aebcf1057005dc1fe041cbd5a3cd5c">value_type</a> &gt;&#160;</td>
          <td class="paramname"><em>default_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const -&gt; std::invoke_result_t&lt;F, <a class="el" href="classbricks_1_1result.html#a21aebcf1057005dc1fe041cbd5a3cd5c">value_type</a>&gt;
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the provided default (if an error) or applies a function to the contained value. </p>
<p >Example: </p><div class="fragment"><div class="line">    <a class="code hl_class" href="classbricks_1_1result.html">bricks::result&lt;int, std::string&gt;</a> res{42};</div>
<div class="line">    CHECK(res.map_or(0, [](<span class="keywordtype">int</span> value) { return value * 2; }) == 84);</div>
<div class="line"> </div>
<div class="line">    res = <span class="stringliteral">&quot;error&quot;</span>;</div>
<div class="line">    CHECK(res.map_or(0, [](<span class="keywordtype">int</span> value) { return value * 2; }) == 0);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">default_value</td><td>The default value to return if the result is an error. </td></tr>
    <tr><td class="paramname">f</td><td>The function to apply if the result is a value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::invoke_result_t&lt;F, value_type&gt; The result of the function. </dd></dl>

</div>
</div>
<a id="ad76b4f4b85fbe87803c8dbf5990cfce9" name="ad76b4f4b85fbe87803c8dbf5990cfce9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad76b4f4b85fbe87803c8dbf5990cfce9">&#9670;&#160;</a></span>map_or_else()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<div class="memtemplate">
template&lt;typename F , typename G &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classbricks_1_1result.html">bricks::result</a>&lt; T, E &gt;::map_or_else </td>
          <td>(</td>
          <td class="paramtype">G &amp;&amp;&#160;</td>
          <td class="paramname"><em>default_f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const -&gt; std::invoke_result_t&lt;F, <a class="el" href="classbricks_1_1result.html#a21aebcf1057005dc1fe041cbd5a3cd5c">value_type</a>&gt;
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Maps the <code>result&lt;T, E&gt;</code> to <code>U</code> by applying fallback function <code>default_f</code> to a contained error, or function <code>f</code> to a contained value. </p>
<p >This function can be used to unpack a successful result while handling an error.</p>
<p >Example: </p><div class="fragment"><div class="line">    <span class="keyword">auto</span> print_and_return = [](<span class="keyword">const</span> std::string&amp; e) {</div>
<div class="line">      INFO(e);</div>
<div class="line">      <span class="keywordflow">return</span> 0;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classbricks_1_1result.html">bricks::result&lt;int, std::string&gt;</a> res{42};</div>
<div class="line">    CHECK(res.map_or_else(print_and_return, [](<span class="keywordtype">int</span> value) { return value * 2; }) == 84);</div>
<div class="line"> </div>
<div class="line">    res = <span class="stringliteral">&quot;error&quot;</span>;</div>
<div class="line">    CHECK(res.map_or_else(print_and_return, [](<span class="keywordtype">int</span> value) { return value * 2; }) == 0);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">default_f</td><td>The fallback function to apply if the result is an error. </td></tr>
    <tr><td class="paramname">f</td><td>The function to apply if the result is a value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::invoke_result_t&lt;F, value_type&gt; The result of the function. </dd></dl>

</div>
</div>
<a id="aa1af7abb0572f392eb6a01c7cf07d6b9" name="aa1af7abb0572f392eb6a01c7cf07d6b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1af7abb0572f392eb6a01c7cf07d6b9">&#9670;&#160;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classbricks_1_1result.html">bricks::result</a>&lt; T, E &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbricks_1_1result.html">result</a>&lt; T, E &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const -&gt; bool
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa3a6ba51579f60baccb3c930aec1ac92" name="aa3a6ba51579f60baccb3c930aec1ac92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3a6ba51579f60baccb3c930aec1ac92">&#9670;&#160;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classbricks_1_1result.html">bricks::result</a>&lt; T, E &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbricks_1_1result.html">result</a>&lt; T, E &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="classbricks_1_1result.html">result</a> &amp;=default</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae1307052d75f3bd58abdc392400bfd95" name="ae1307052d75f3bd58abdc392400bfd95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1307052d75f3bd58abdc392400bfd95">&#9670;&#160;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classbricks_1_1result.html">bricks::result</a>&lt; T, E &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbricks_1_1result.html">result</a>&lt; T, E &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  <a class="el" href="classbricks_1_1result.html">result</a> &amp;=default</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af4bd155e31761eef73f6f6d216ec7b6d" name="af4bd155e31761eef73f6f6d216ec7b6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4bd155e31761eef73f6f6d216ec7b6d">&#9670;&#160;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classbricks_1_1result.html">bricks::result</a>&lt; T, E &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">U&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classbricks_1_1result.html">result</a>&amp;
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assign a value to the result. </p>
<p >If the value and error types are the same, one must use the <code>ok&lt;T&gt;</code> and <code>err&lt;E&gt;</code> types for the assignment. Otherwise the value type must be convertible to the value type of the result. And the error type must be convertible to the error type of the result.</p>
<p >Example: </p><div class="fragment"><div class="line">    <a class="code hl_class" href="classbricks_1_1result.html">bricks::result&lt;int, std::string&gt;</a> res{<span class="stringliteral">&quot;error&quot;</span>};</div>
<div class="line">    CHECK(res.is_error());</div>
<div class="line"> </div>
<div class="line">    res = 42;</div>
<div class="line">    CHECK(res.is_value());</div>
<div class="line"> </div>
<div class="line">    res = <span class="stringliteral">&quot;error&quot;</span>;</div>
<div class="line">    CHECK(res.is_error());</div>
<div class="line"> </div>
<div class="line">    res = <a class="code hl_typedef" href="namespacebricks.html#a19b2ba7d93c79fd196404d3fc50eac4f">ok&lt;int&gt;</a>{42};</div>
<div class="line">    CHECK(res.is_value());</div>
<div class="line"> </div>
<div class="line">    res = err&lt;std::string&gt;{<span class="stringliteral">&quot;error&quot;</span>};</div>
<div class="line">    CHECK(res.is_error());</div>
<div class="ttc" id="anamespacebricks_html_a19b2ba7d93c79fd196404d3fc50eac4f"><div class="ttname"><a href="namespacebricks.html#a19b2ba7d93c79fd196404d3fc50eac4f">bricks::ok</a></div><div class="ttdeci">detail::value_container&lt; T, detail::ok_tag &gt; ok</div><div class="ttdef"><b>Definition:</b> result.hpp:74</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a9af552af9e7ce8ad3c44fa9817cee4bc" name="a9af552af9e7ce8ad3c44fa9817cee4bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9af552af9e7ce8ad3c44fa9817cee4bc">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classbricks_1_1result.html">bricks::result</a>&lt; T, E &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbricks_1_1result.html">result</a>&lt; T, E &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const -&gt; bool
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a991a1ce1aae6e77000728b2b415ee77e" name="a991a1ce1aae6e77000728b2b415ee77e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a991a1ce1aae6e77000728b2b415ee77e">&#9670;&#160;</a></span>or_else()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<div class="memtemplate">
template&lt;typename Op &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classbricks_1_1result.html">bricks::result</a>&lt; T, E &gt;::or_else </td>
          <td>(</td>
          <td class="paramtype">Op &amp;&amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const -&gt; <a class="el" href="classbricks_1_1result.html">result</a>&lt;<a class="el" href="classbricks_1_1result.html#a21aebcf1057005dc1fe041cbd5a3cd5c">value_type</a>, typename std::invoke_result_t&lt;Op, <a class="el" href="classbricks_1_1result.html#a9b8311e26db21f89e2482a499ef13b6c">error_type</a>&gt;<a class="el" href="classbricks_1_1result.html#a9b8311e26db21f89e2482a499ef13b6c">::error_type</a>&gt;
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls <code>op</code> if the result is an error, otherwise returns the value. </p>
<p >This function can be used for control flow based on result values.</p>
<p >Example: </p><div class="fragment"><div class="line">    <span class="keyword">auto</span> parse_int = [](<span class="keyword">const</span> std::string&amp; s) -&gt; <a class="code hl_class" href="classbricks_1_1result.html">result&lt;int, std::invalid_argument&gt;</a> {</div>
<div class="line">      <span class="keywordflow">try</span> {</div>
<div class="line">        <span class="keywordflow">return</span> {std::stoi(s)};</div>
<div class="line">      } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::invalid_argument&amp; e) {</div>
<div class="line">        <span class="keywordflow">return</span> {e};</div>
<div class="line">      }</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">auto</span> parse_invalid_argument = [](<span class="keyword">const</span> std::invalid_argument&amp; e) {</div>
<div class="line">      <span class="keywordflow">return</span> result&lt;int, std::string&gt;{std::string{<span class="stringliteral">&quot;Couldn&#39;t parse: &quot;</span>} + e.what()};</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classbricks_1_1result.html">bricks::result&lt;std::string, std::invalid_argument&gt;</a> res{<span class="stringliteral">&quot;42&quot;</span>};</div>
<div class="line">    CHECK(res.and_then(parse_int)               <span class="comment">// result&lt;int, std::invalid_argument&gt;</span></div>
<div class="line">              .or_else(parse_invalid_argument)  <span class="comment">// result&lt;int, std::string&gt;</span></div>
<div class="line">              .unwrap() == 42);</div>
<div class="line"> </div>
<div class="line">    res = <span class="stringliteral">&quot;not a number&quot;</span>;</div>
<div class="line">    CHECK(res.and_then(parse_int)               <span class="comment">// result&lt;int, std::invalid_argument&gt;</span></div>
<div class="line">              .or_else(parse_invalid_argument)  <span class="comment">// result&lt;int, std::string&gt;</span></div>
<div class="line">              .unwrap_error() == <span class="stringliteral">&quot;Couldn&#39;t parse: stoi&quot;</span>);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">op</td><td>The operation to perform on the error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result&lt;value_type, F&gt; </dd></dl>

</div>
</div>
<a id="a4d719a837004ecf8f36db40458c9e132" name="a4d719a837004ecf8f36db40458c9e132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d719a837004ecf8f36db40458c9e132">&#9670;&#160;</a></span>or_instead()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classbricks_1_1result.html">bricks::result</a>&lt; T, E &gt;::or_instead </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbricks_1_1result.html">result</a>&lt; <a class="el" href="classbricks_1_1result.html#a21aebcf1057005dc1fe041cbd5a3cd5c">value_type</a>, F &gt; &amp;&#160;</td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td> const -&gt; <a class="el" href="classbricks_1_1result.html">result</a>&lt;<a class="el" href="classbricks_1_1result.html#a21aebcf1057005dc1fe041cbd5a3cd5c">value_type</a>, F&gt;
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>res</code> if the result is an error, otherwise returns the value. </p>
<p >This function can be used for control flow based on result values.</p>
<p >Example: </p><div class="fragment"><div class="line">    <span class="keyword">auto</span> parse_int = [](<span class="keyword">const</span> std::string&amp; s) -&gt; <a class="code hl_class" href="classbricks_1_1result.html">result&lt;int, std::invalid_argument&gt;</a> {</div>
<div class="line">      <span class="keywordflow">try</span> {</div>
<div class="line">        <span class="keywordflow">return</span> {std::stoi(s)};</div>
<div class="line">      } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::invalid_argument&amp; e) {</div>
<div class="line">        <span class="keywordflow">return</span> {e};</div>
<div class="line">      }</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classbricks_1_1result.html">bricks::result&lt;std::string, std::invalid_argument&gt;</a> res{<span class="stringliteral">&quot;42&quot;</span>};</div>
<div class="line">    CHECK(res.and_then(parse_int)  <span class="comment">// result&lt;int, std::invalid_argument&gt;</span></div>
<div class="line">              .or_instead(result&lt;int, std::string&gt;{<span class="stringliteral">&quot;Couldn&#39;t parse&quot;</span>})</div>
<div class="line">              .unwrap() == 42);</div>
<div class="line"> </div>
<div class="line">    res = <span class="stringliteral">&quot;not a number&quot;</span>;</div>
<div class="line">    CHECK(res.and_then(parse_int)  <span class="comment">// result&lt;int, std::invalid_argument&gt;</span></div>
<div class="line">              .or_instead(result&lt;int, std::string&gt;{<span class="stringliteral">&quot;Couldn&#39;t parse&quot;</span>})</div>
<div class="line">              .unwrap_error() == <span class="stringliteral">&quot;Couldn&#39;t parse&quot;</span>);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>The result to return if the result is an error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result&lt;value_type, F&gt; The result of the function. </dd></dl>

</div>
</div>
<a id="a6b984365b5611cafe6c5ad8ebfa3fa9c" name="a6b984365b5611cafe6c5ad8ebfa3fa9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b984365b5611cafe6c5ad8ebfa3fa9c">&#9670;&#160;</a></span>unwrap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classbricks_1_1result.html">bricks::result</a>&lt; T, E &gt;::unwrap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classbricks_1_1result.html#a21aebcf1057005dc1fe041cbd5a3cd5c">value_type</a>
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of the result. </p>
<p >Throws a <code><a class="el" href="classbricks_1_1bad__result__access.html" title="This is the type of the error thrown when accessing a bad result.">bad_result_access</a></code> if the result is an error.</p>
<p >Example: </p><div class="fragment"><div class="line">    <a class="code hl_class" href="classbricks_1_1result.html">bricks::result&lt;int, std::string&gt;</a> res{<span class="stringliteral">&quot;error&quot;</span>};</div>
<div class="line">    CHECK_THROWS_WITH_AS([[maybe_unused]] <span class="keyword">const</span> <span class="keyword">auto</span> ret = res.unwrap(),</div>
<div class="line">                         <span class="stringliteral">&quot;Called `unwrap` on a result that is an error.&quot;</span>,</div>
<div class="line">                         <a class="code hl_class" href="classbricks_1_1bad__result__access.html">bricks::bad_result_access</a>);</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>value_type The value of the result. </dd></dl>

</div>
</div>
<a id="aa2f4125f05de654ebb7033939dd1de51" name="aa2f4125f05de654ebb7033939dd1de51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2f4125f05de654ebb7033939dd1de51">&#9670;&#160;</a></span>unwrap_error()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classbricks_1_1result.html">bricks::result</a>&lt; T, E &gt;::unwrap_error </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classbricks_1_1result.html#a9b8311e26db21f89e2482a499ef13b6c">error_type</a>
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the error of the result. </p>
<p >Throws a <code><a class="el" href="classbricks_1_1bad__result__access.html" title="This is the type of the error thrown when accessing a bad result.">bad_result_access</a></code> if the result is a value.</p>
<p >Example: </p><div class="fragment"><div class="line">    <a class="code hl_class" href="classbricks_1_1result.html">bricks::result&lt;int, std::string&gt;</a> res{42};</div>
<div class="line">    CHECK_THROWS_WITH_AS([[maybe_unused]] <span class="keyword">const</span> <span class="keyword">auto</span> ret = res.unwrap_error(),</div>
<div class="line">                         <span class="stringliteral">&quot;Called `unwrap_error` on a result that is a value.&quot;</span>,</div>
<div class="line">                         <a class="code hl_class" href="classbricks_1_1bad__result__access.html">bricks::bad_result_access</a>);</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>error_type The error of the result. </dd></dl>

</div>
</div>
<a id="adc5b09e34960d2afbcae03264a65f595" name="adc5b09e34960d2afbcae03264a65f595"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc5b09e34960d2afbcae03264a65f595">&#9670;&#160;</a></span>unwrap_or()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classbricks_1_1result.html">bricks::result</a>&lt; T, E &gt;::unwrap_or </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbricks_1_1result.html#a21aebcf1057005dc1fe041cbd5a3cd5c">value_type</a>&#160;</td>
          <td class="paramname"><em>default_value</em></td><td>)</td>
          <td> const -&gt; <a class="el" href="classbricks_1_1result.html#a21aebcf1057005dc1fe041cbd5a3cd5c">value_type</a>
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of the result. </p>
<p >If the result is a value, returns the value. If the result is an error, returns the provided default value.</p>
<p >Example: </p><div class="fragment"><div class="line">    <a class="code hl_class" href="classbricks_1_1result.html">bricks::result&lt;int, std::string&gt;</a> res{42};</div>
<div class="line">    CHECK(res.unwrap_or(0) == 42);</div>
<div class="line"> </div>
<div class="line">    res = <span class="stringliteral">&quot;error&quot;</span>;</div>
<div class="line">    CHECK(res.unwrap_or(0) == 0);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">default_value</td><td>The default value to return if the result is an error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value_type The value of the result. </dd></dl>

</div>
</div>
<a id="abaccfa91669612eaa548f3e889d6bc43" name="abaccfa91669612eaa548f3e889d6bc43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaccfa91669612eaa548f3e889d6bc43">&#9670;&#160;</a></span>unwrap_or_default()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classbricks_1_1result.html">bricks::result</a>&lt; T, E &gt;::unwrap_or_default </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; <a class="el" href="classbricks_1_1result.html#a21aebcf1057005dc1fe041cbd5a3cd5c">value_type</a>
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of the result or a default constructed value. </p>
<p >If the result is a value, returns the value. If the result is an error, returns the default constructed value.</p>
<p >Example: </p><div class="fragment"><div class="line">    <a class="code hl_class" href="classbricks_1_1result.html">bricks::result&lt;int, std::string&gt;</a> res{42};</div>
<div class="line">    CHECK(res.unwrap_or_default() == 42);</div>
<div class="line"> </div>
<div class="line">    res = <span class="stringliteral">&quot;error&quot;</span>;</div>
<div class="line">    CHECK(res.unwrap_or_default() == 0);</div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>value_type The value of the result. </dd></dl>

</div>
</div>
<a id="ab467ecbc8adfc40cce5196ca220bc07c" name="ab467ecbc8adfc40cce5196ca220bc07c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab467ecbc8adfc40cce5196ca220bc07c">&#9670;&#160;</a></span>unwrap_or_else()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto <a class="el" href="classbricks_1_1result.html">bricks::result</a>&lt; T, E &gt;::unwrap_or_else </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const -&gt; <a class="el" href="classbricks_1_1result.html#a21aebcf1057005dc1fe041cbd5a3cd5c">value_type</a>
  </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of the result or the result of a function. </p>
<p >If the result is a value, returns the value. If the result is an error, returns the result of calling the provided function.</p>
<p >Example: </p><div class="fragment"><div class="line">    <span class="keyword">auto</span> print_and_return = [](<span class="keyword">const</span> std::string&amp; e) {</div>
<div class="line">      INFO(e);</div>
<div class="line">      <span class="keywordflow">return</span> 0;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <a class="code hl_class" href="classbricks_1_1result.html">bricks::result&lt;int, std::string&gt;</a> res{42};</div>
<div class="line">    CHECK(res.unwrap_or_else(print_and_return) == 42);</div>
<div class="line"> </div>
<div class="line">    res = <span class="stringliteral">&quot;error&quot;</span>;</div>
<div class="line">    CHECK(res.unwrap_or_else(print_and_return) == 0);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to call if the result is an error. The function must take a single parameter of type <code>error_type</code> and return a value of type <code>value_type</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value_type The value of the result. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="aa8eaf1c31aa744d327f502c63cc6881e" name="aa8eaf1c31aa744d327f502c63cc6881e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8eaf1c31aa744d327f502c63cc6881e">&#9670;&#160;</a></span>std::hash</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto std::hash </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbricks_1_1result.html">result</a>&lt; T, E &gt; &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const -&gt;  std::size_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/github/workspace/include/bricks/<a class="el" href="result_8hpp_source.html">result.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacebricks.html">bricks</a></li><li class="navelem"><a class="el" href="classbricks_1_1result.html">result</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
