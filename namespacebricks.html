<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=9" />
    <meta name="generator" content="Doxygen 1.9.5" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>BRICKS: bricks Namespace Reference</title>
    <link href="tabs.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript">
        DoxygenAwesomeDarkModeToggle.init()
    </script>
    <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
    <script type="text/javascript">
        DoxygenAwesomeFragmentCopyButton.init()
    </script>
    <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
    <script type="text/javascript">
        DoxygenAwesomeParagraphLink.init()
    </script>
    <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
    <script type="text/javascript">
        DoxygenAwesomeInteractiveToc.init()
    </script>
</head>
<body>
    <div id="top">
        <!-- do not remove this div, it is closed by doxygen! -->
        <div id="titlearea">
            <table cellspacing="0" cellpadding="0">
                <tbody>
                    <tr style="height: 56px;">
                        <td id="projectlogo"><img alt="Logo" src="logo.png" /></td>
                        <td id="projectalign" style="padding-left: 0.5em;">
                            <div id="projectname">BRICKS
                            </div>
                            <div id="projectbrief">Small, useful blocks of code, to build bigger things.</div>
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
        <!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespacebricks.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">bricks Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbricks_1_1bad__result__access.html">bad_result_access</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the type of the error thrown when accessing a bad result.  <a href="classbricks_1_1bad__result__access.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbricks_1_1has__find.html">has_find</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a type has a <code>find</code> method taking a specific type.  <a href="structbricks_1_1has__find.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbricks_1_1is__iterator.html">is_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a type is an iterator.  <a href="structbricks_1_1is__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbricks_1_1mutex.html">mutex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mutual exclusion primitive that can be used to protect shared data.  <a href="classbricks_1_1mutex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbricks_1_1result.html">result</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to represent the result of an operation.  <a href="classbricks_1_1result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbricks_1_1rw__lock.html">rw_lock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reader-writer lock.  <a href="classbricks_1_1rw__lock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbricks_1_1timer.html">timer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A timer that can be started and aborted.  <a href="classbricks_1_1timer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a19b2ba7d93c79fd196404d3fc50eac4f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a19b2ba7d93c79fd196404d3fc50eac4f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebricks.html#a19b2ba7d93c79fd196404d3fc50eac4f">ok</a> = detail::value_container&lt; T, detail::ok_tag &gt;</td></tr>
<tr class="separator:a19b2ba7d93c79fd196404d3fc50eac4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56141134ef4783cc27e2f3e970dbedf5"><td class="memTemplParams" colspan="2">template&lt;typename E &gt; </td></tr>
<tr class="memitem:a56141134ef4783cc27e2f3e970dbedf5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebricks.html#a56141134ef4783cc27e2f3e970dbedf5">err</a> = detail::value_container&lt; E, detail::err_tag &gt;</td></tr>
<tr class="separator:a56141134ef4783cc27e2f3e970dbedf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a86002e9c15976d8002fb8b18f6f20c84"><td class="memTemplParams" colspan="2">template&lt;class Container &gt; </td></tr>
<tr class="memitem:a86002e9c15976d8002fb8b18f6f20c84"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebricks.html#a86002e9c15976d8002fb8b18f6f20c84">keys</a> (const Container &amp;input_map) -&gt; std::vector&lt; typename Container::key_type &gt;</td></tr>
<tr class="memdesc:a86002e9c15976d8002fb8b18f6f20c84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the keys of an associative container.  <a href="namespacebricks.html#a86002e9c15976d8002fb8b18f6f20c84">More...</a><br /></td></tr>
<tr class="separator:a86002e9c15976d8002fb8b18f6f20c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73112939fcac4c4eced690eff476e781"><td class="memTemplParams" colspan="2">template&lt;class Container &gt; </td></tr>
<tr class="memitem:a73112939fcac4c4eced690eff476e781"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebricks.html#a73112939fcac4c4eced690eff476e781">values</a> (const Container &amp;input_map) -&gt; std::vector&lt; typename Container::mapped_type &gt;</td></tr>
<tr class="memdesc:a73112939fcac4c4eced690eff476e781"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the values of an associative container.  <a href="namespacebricks.html#a73112939fcac4c4eced690eff476e781">More...</a><br /></td></tr>
<tr class="separator:a73112939fcac4c4eced690eff476e781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ad8c274821ef9eaf034b382a7dfadaf"><td class="memTemplParams" colspan="2">template&lt;typename F , typename... FrontArgs&gt; </td></tr>
<tr class="memitem:a6ad8c274821ef9eaf034b382a7dfadaf"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebricks.html#a6ad8c274821ef9eaf034b382a7dfadaf">bind_front</a> (F &amp;&amp;f, FrontArgs &amp;&amp;... front_args)</td></tr>
<tr class="memdesc:a6ad8c274821ef9eaf034b382a7dfadaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind arguments to the front of a function.  <a href="namespacebricks.html#a6ad8c274821ef9eaf034b382a7dfadaf">More...</a><br /></td></tr>
<tr class="separator:a6ad8c274821ef9eaf034b382a7dfadaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36ed2e34e70f88bd62f952a412b852fd"><td class="memTemplParams" colspan="2">template&lt;class Container , class UnaryPredicate &gt; </td></tr>
<tr class="memitem:a36ed2e34e70f88bd62f952a412b852fd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebricks.html#a36ed2e34e70f88bd62f952a412b852fd">filter</a> (const Container &amp;container, const UnaryPredicate &amp;predicate) -&gt; Container</td></tr>
<tr class="memdesc:a36ed2e34e70f88bd62f952a412b852fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter a container using a predicate.  <a href="namespacebricks.html#a36ed2e34e70f88bd62f952a412b852fd">More...</a><br /></td></tr>
<tr class="separator:a36ed2e34e70f88bd62f952a412b852fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b10cd3eefc9387e44407e45c0cfc9c2"><td class="memTemplParams" colspan="2">template&lt;class Container , class Value &gt; </td></tr>
<tr class="memitem:a2b10cd3eefc9387e44407e45c0cfc9c2"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebricks.html#a2b10cd3eefc9387e44407e45c0cfc9c2">contains</a> (const Container &amp;container, const Value &amp;value) noexcept -&gt; bool</td></tr>
<tr class="memdesc:a2b10cd3eefc9387e44407e45c0cfc9c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a container contains a specific value.  <a href="namespacebricks.html#a2b10cd3eefc9387e44407e45c0cfc9c2">More...</a><br /></td></tr>
<tr class="separator:a2b10cd3eefc9387e44407e45c0cfc9c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af648dddfb613afc30701c8df34f0bb19"><td class="memTemplParams" colspan="2">template&lt;class Container , class UnaryPredicate &gt; </td></tr>
<tr class="memitem:af648dddfb613afc30701c8df34f0bb19"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebricks.html#af648dddfb613afc30701c8df34f0bb19">contains_if</a> (const Container &amp;container, const UnaryPredicate &amp;predicate) -&gt; bool</td></tr>
<tr class="memdesc:af648dddfb613afc30701c8df34f0bb19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a container contains a value that satisfies a predicate.  <a href="namespacebricks.html#af648dddfb613afc30701c8df34f0bb19">More...</a><br /></td></tr>
<tr class="separator:af648dddfb613afc30701c8df34f0bb19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f82ab9b5978f3b76b4de90de73a951d"><td class="memTemplParams" colspan="2">template&lt;class Container , class Value &gt; </td></tr>
<tr class="memitem:a5f82ab9b5978f3b76b4de90de73a951d"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebricks.html#a5f82ab9b5978f3b76b4de90de73a951d">index_of</a> (const Container &amp;container, const Value &amp;value) noexcept -&gt; std::optional&lt; size_t &gt;</td></tr>
<tr class="memdesc:a5f82ab9b5978f3b76b4de90de73a951d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of the first occurence of a value in a container.  <a href="namespacebricks.html#a5f82ab9b5978f3b76b4de90de73a951d">More...</a><br /></td></tr>
<tr class="separator:a5f82ab9b5978f3b76b4de90de73a951d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ad262015be72bc9400dd9332ddc3b03"><td class="memTemplParams" colspan="2">template&lt;class Container , class UnaryPredicate &gt; </td></tr>
<tr class="memitem:a0ad262015be72bc9400dd9332ddc3b03"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebricks.html#a0ad262015be72bc9400dd9332ddc3b03">index_of_if</a> (const Container &amp;container, const UnaryPredicate &amp;predicate) -&gt; std::optional&lt; size_t &gt;</td></tr>
<tr class="memdesc:a0ad262015be72bc9400dd9332ddc3b03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of the first element in a container for which a predicate is true.  <a href="namespacebricks.html#a0ad262015be72bc9400dd9332ddc3b03">More...</a><br /></td></tr>
<tr class="separator:a0ad262015be72bc9400dd9332ddc3b03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afec1449ef3e22e63547887744c4111a9"><td class="memTemplParams" colspan="2">template&lt;class T , class Rep , class Period &gt; </td></tr>
<tr class="memitem:afec1449ef3e22e63547887744c4111a9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebricks.html#afec1449ef3e22e63547887744c4111a9">is_ready_after</a> (const std::future&lt; T &gt; &amp;future, const std::chrono::duration&lt; Rep, Period &gt; &amp;timeout) noexcept -&gt; bool</td></tr>
<tr class="memdesc:afec1449ef3e22e63547887744c4111a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a future is ready after a timeout.  <a href="namespacebricks.html#afec1449ef3e22e63547887744c4111a9">More...</a><br /></td></tr>
<tr class="separator:afec1449ef3e22e63547887744c4111a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e2fa4c1a3e3459b3cea78f1d796564"><td class="memTemplParams" colspan="2">template&lt;class T , class Clock , class Duration &gt; </td></tr>
<tr class="memitem:a81e2fa4c1a3e3459b3cea78f1d796564"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebricks.html#a81e2fa4c1a3e3459b3cea78f1d796564">is_ready_at</a> (const std::future&lt; T &gt; &amp;future, const std::chrono::time_point&lt; Clock, Duration &gt; &amp;timeout) noexcept -&gt; bool</td></tr>
<tr class="memdesc:a81e2fa4c1a3e3459b3cea78f1d796564"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a future is ready at a specific time.  <a href="namespacebricks.html#a81e2fa4c1a3e3459b3cea78f1d796564">More...</a><br /></td></tr>
<tr class="separator:a81e2fa4c1a3e3459b3cea78f1d796564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab48b3432f6b25c66c5669c3b5cdb6114"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab48b3432f6b25c66c5669c3b5cdb6114"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebricks.html#ab48b3432f6b25c66c5669c3b5cdb6114">to_string</a> (const T &amp;value, std::string &amp;str) noexcept -&gt; bool</td></tr>
<tr class="memdesc:ab48b3432f6b25c66c5669c3b5cdb6114"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exceptionlessly convert a number to a string.  <a href="namespacebricks.html#ab48b3432f6b25c66c5669c3b5cdb6114">More...</a><br /></td></tr>
<tr class="separator:ab48b3432f6b25c66c5669c3b5cdb6114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579b90b8768aaa590ffeb462ac0d5535"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a579b90b8768aaa590ffeb462ac0d5535"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebricks.html#a579b90b8768aaa590ffeb462ac0d5535">from_string</a> (const std::string_view &amp;str, T &amp;value) noexcept -&gt; bool</td></tr>
<tr class="memdesc:a579b90b8768aaa590ffeb462ac0d5535"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exceptionlessly convert a string to a number.  <a href="namespacebricks.html#a579b90b8768aaa590ffeb462ac0d5535">More...</a><br /></td></tr>
<tr class="separator:a579b90b8768aaa590ffeb462ac0d5535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3ae00555224508fa002c2d40d0c83b0"><td class="memTemplParams" colspan="2">template&lt;typename Range &gt; </td></tr>
<tr class="memitem:ab3ae00555224508fa002c2d40d0c83b0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebricks.html#ab3ae00555224508fa002c2d40d0c83b0">enumerate</a> (Range &amp;range)</td></tr>
<tr class="memdesc:ab3ae00555224508fa002c2d40d0c83b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerate a range.  <a href="namespacebricks.html#ab3ae00555224508fa002c2d40d0c83b0">More...</a><br /></td></tr>
<tr class="separator:ab3ae00555224508fa002c2d40d0c83b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a437b5370782493b27a27d8882521d96e"><td class="memTemplParams" colspan="2">template&lt;typename Range &gt; </td></tr>
<tr class="memitem:a437b5370782493b27a27d8882521d96e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebricks.html#a437b5370782493b27a27d8882521d96e">reverse</a> (Range &amp;range)</td></tr>
<tr class="memdesc:a437b5370782493b27a27d8882521d96e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a reverse iterator from a range.  <a href="namespacebricks.html#a437b5370782493b27a27d8882521d96e">More...</a><br /></td></tr>
<tr class="separator:a437b5370782493b27a27d8882521d96e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a464e63cab89ecd30b76fb2f3ed206f00"><td class="memTemplParams" colspan="2">template&lt;typename... Ranges&gt; </td></tr>
<tr class="memitem:a464e63cab89ecd30b76fb2f3ed206f00"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebricks.html#a464e63cab89ecd30b76fb2f3ed206f00">zip</a> (Ranges &amp;&amp;... t)</td></tr>
<tr class="memdesc:a464e63cab89ecd30b76fb2f3ed206f00"><td class="mdescLeft">&#160;</td><td class="mdescRight">A zip iterator adapter.  <a href="namespacebricks.html#a464e63cab89ecd30b76fb2f3ed206f00">More...</a><br /></td></tr>
<tr class="separator:a464e63cab89ecd30b76fb2f3ed206f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:af33da0798fa7e1c13559de8d320713de"><td class="memTemplParams" colspan="2">template&lt;class &gt; </td></tr>
<tr class="memitem:af33da0798fa7e1c13559de8d320713de"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebricks.html#af33da0798fa7e1c13559de8d320713de">always_false_v</a> = false</td></tr>
<tr class="memdesc:af33da0798fa7e1c13559de8d320713de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template for static assertions.  <a href="namespacebricks.html#af33da0798fa7e1c13559de8d320713de">More...</a><br /></td></tr>
<tr class="separator:af33da0798fa7e1c13559de8d320713de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a674ac3c278cdcc59916c6121329f13b8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a674ac3c278cdcc59916c6121329f13b8"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebricks.html#a674ac3c278cdcc59916c6121329f13b8">is_iterator_v</a> = <a class="el" href="structbricks_1_1is__iterator.html">is_iterator</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:a674ac3c278cdcc59916c6121329f13b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template to check if a type is an iterator.  <a href="namespacebricks.html#a674ac3c278cdcc59916c6121329f13b8">More...</a><br /></td></tr>
<tr class="separator:a674ac3c278cdcc59916c6121329f13b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a56141134ef4783cc27e2f3e970dbedf5" name="a56141134ef4783cc27e2f3e970dbedf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56141134ef4783cc27e2f3e970dbedf5">&#9670;&#160;</a></span>err</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacebricks.html#a56141134ef4783cc27e2f3e970dbedf5">bricks::err</a> = typedef detail::value_container&lt;E, detail::err_tag&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a19b2ba7d93c79fd196404d3fc50eac4f" name="a19b2ba7d93c79fd196404d3fc50eac4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19b2ba7d93c79fd196404d3fc50eac4f">&#9670;&#160;</a></span>ok</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacebricks.html#a19b2ba7d93c79fd196404d3fc50eac4f">bricks::ok</a> = typedef detail::value_container&lt;T, detail::ok_tag&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a6ad8c274821ef9eaf034b382a7dfadaf" name="a6ad8c274821ef9eaf034b382a7dfadaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ad8c274821ef9eaf034b382a7dfadaf">&#9670;&#160;</a></span>bind_front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename... FrontArgs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto bricks::bind_front </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FrontArgs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>front_args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind arguments to the front of a function. </p>
<p >C++17 implementation of the C++20 <code>std::bind_front(...)</code> function.</p>
<p >Example: </p><div class="fragment"><div class="line">    <span class="keyword">auto</span> add = [](<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b) { <span class="keywordflow">return</span> a + b; };</div>
<div class="line">    <span class="keyword">auto</span> add_1 = <a class="code hl_function" href="namespacebricks.html#a6ad8c274821ef9eaf034b382a7dfadaf">bricks::bind_front</a>(add, 1);</div>
<div class="line">    INFO(add_1(2));  <span class="comment">// prints 3</span></div>
<div class="ttc" id="anamespacebricks_html_a6ad8c274821ef9eaf034b382a7dfadaf"><div class="ttname"><a href="namespacebricks.html#a6ad8c274821ef9eaf034b382a7dfadaf">bricks::bind_front</a></div><div class="ttdeci">constexpr auto bind_front(F &amp;&amp;f, FrontArgs &amp;&amp;... front_args)</div><div class="ttdoc">Bind arguments to the front of a function.</div><div class="ttdef"><b>Definition:</b> algorithm.hpp:68</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to bind front arguments to. </td></tr>
    <tr><td class="paramname">front_args</td><td>The front arguments to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b10cd3eefc9387e44407e45c0cfc9c2" name="a2b10cd3eefc9387e44407e45c0cfc9c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b10cd3eefc9387e44407e45c0cfc9c2">&#9670;&#160;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container , class Value &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto bricks::contains </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Value &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether a container contains a specific value. </p>
<p >If the container has a <code>find</code> method, it will be used to check if the container contains the value. Otherwise, the container will be searched using <code>std::find</code>. If <code>std::find</code> is used, the container must have a <code>begin</code> and <code>end</code> method. If the container has a <code>find</code> method, the container must have a <code>key_type</code> type alias. If <code>std::find</code> throws an exception, <code>std::terminate</code> will be called.</p>
<p >Example: </p><div class="fragment"><div class="line">    std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5};</div>
<div class="line">    INFO(<a class="code hl_function" href="namespacebricks.html#a2b10cd3eefc9387e44407e45c0cfc9c2">bricks::contains</a>(vec, 3));  <span class="comment">// prints true</span></div>
<div class="line">    INFO(<a class="code hl_function" href="namespacebricks.html#a2b10cd3eefc9387e44407e45c0cfc9c2">bricks::contains</a>(vec, 6));  <span class="comment">// prints false</span></div>
<div class="ttc" id="anamespacebricks_html_a2b10cd3eefc9387e44407e45c0cfc9c2"><div class="ttname"><a href="namespacebricks.html#a2b10cd3eefc9387e44407e45c0cfc9c2">bricks::contains</a></div><div class="ttdeci">constexpr auto contains(const Container &amp;container, const Value &amp;value) noexcept -&gt; bool</div><div class="ttdoc">Checks whether a container contains a specific value.</div><div class="ttdef"><b>Definition:</b> algorithm.hpp:117</div></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>The type of the container. </td></tr>
    <tr><td class="paramname">Value</td><td>The type of the value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>The container. </td></tr>
    <tr><td class="paramname">value</td><td>The value to check for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If the container contains the value, false otherwise. </dd></dl>

</div>
</div>
<a id="af648dddfb613afc30701c8df34f0bb19" name="af648dddfb613afc30701c8df34f0bb19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af648dddfb613afc30701c8df34f0bb19">&#9670;&#160;</a></span>contains_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container , class UnaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto bricks::contains_if </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UnaryPredicate &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a container contains a value that satisfies a predicate. </p>
<p >Example: </p><div class="fragment"><div class="line">    std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5};</div>
<div class="line">    INFO(<a class="code hl_function" href="namespacebricks.html#af648dddfb613afc30701c8df34f0bb19">bricks::contains_if</a>(vec, [](<span class="keywordtype">int</span> i) { <span class="keywordflow">return</span> i % 2 == 0; }));  <span class="comment">// prints true</span></div>
<div class="ttc" id="anamespacebricks_html_af648dddfb613afc30701c8df34f0bb19"><div class="ttname"><a href="namespacebricks.html#af648dddfb613afc30701c8df34f0bb19">bricks::contains_if</a></div><div class="ttdeci">constexpr auto contains_if(const Container &amp;container, const UnaryPredicate &amp;predicate) -&gt; bool</div><div class="ttdoc">Checks if a container contains a value that satisfies a predicate.</div><div class="ttdef"><b>Definition:</b> algorithm.hpp:135</div></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>The type of the container. </td></tr>
    <tr><td class="paramname">UnaryPredicate</td><td>The type of the predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>The container. </td></tr>
    <tr><td class="paramname">predicate</td><td>The predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If the container contains a value that satisfies the predicate, false otherwise. </dd></dl>

</div>
</div>
<a id="ab3ae00555224508fa002c2d40d0c83b0" name="ab3ae00555224508fa002c2d40d0c83b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3ae00555224508fa002c2d40d0c83b0">&#9670;&#160;</a></span>enumerate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto bricks::enumerate </td>
          <td>(</td>
          <td class="paramtype">Range &amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerate a range. </p>
<p >This function creates an enumerator from a range. The range can be any type that has a begin and end function. The enumerator can be used in a range-based for loop. Each element in the enumerator is a pair of the index and the value.</p>
<p >Example: </p><div class="fragment"><div class="line">  std::vector&lt;int&gt; v{1, 2, 3, 4, 5};</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> [i, e] : <a class="code hl_function" href="namespacebricks.html#ab3ae00555224508fa002c2d40d0c83b0">bricks::enumerate</a>(v)) {</div>
<div class="line">    <span class="keyword">auto</span> idx = i;</div>
<div class="line">    <span class="keyword">auto</span> elem = e;</div>
<div class="line">    INFO(idx, <span class="stringliteral">&quot;: &quot;</span>, elem);  <span class="comment">// prints 0: 1, 1: 2, 2: 3, 3: 4, 4: 5</span></div>
<div class="line">  }</div>
<div class="ttc" id="anamespacebricks_html_ab3ae00555224508fa002c2d40d0c83b0"><div class="ttname"><a href="namespacebricks.html#ab3ae00555224508fa002c2d40d0c83b0">bricks::enumerate</a></div><div class="ttdeci">auto enumerate(Range &amp;range)</div><div class="ttdoc">Enumerate a range.</div><div class="ttdef"><b>Definition:</b> enumerate.hpp:24</div></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Range</td><td>The type of range to enumerate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>The range to enumerate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>auto An enumerator. </dd></dl>

</div>
</div>
<a id="a36ed2e34e70f88bd62f952a412b852fd" name="a36ed2e34e70f88bd62f952a412b852fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36ed2e34e70f88bd62f952a412b852fd">&#9670;&#160;</a></span>filter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container , class UnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto bricks::filter </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UnaryPredicate &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; Container
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filter a container using a predicate. </p>
<p >Creates a new container of type <code>Container</code>, with the elements that satisfy the predicate.</p>
<p >Example: </p><div class="fragment"><div class="line">    std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5};</div>
<div class="line">    <span class="keyword">auto</span> filtered = <a class="code hl_function" href="namespacebricks.html#a36ed2e34e70f88bd62f952a412b852fd">bricks::filter</a>(vec, [](<span class="keywordtype">int</span> i) { <span class="keywordflow">return</span> i % 2 == 0; });</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> i : filtered) {</div>
<div class="line">      INFO(i);  <span class="comment">// prints 2, 4</span></div>
<div class="line">    }</div>
<div class="ttc" id="anamespacebricks_html_a36ed2e34e70f88bd62f952a412b852fd"><div class="ttname"><a href="namespacebricks.html#a36ed2e34e70f88bd62f952a412b852fd">bricks::filter</a></div><div class="ttdeci">auto filter(const Container &amp;container, const UnaryPredicate &amp;predicate) -&gt; Container</div><div class="ttdoc">Filter a container using a predicate.</div><div class="ttdef"><b>Definition:</b> algorithm.hpp:91</div></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>The type of the container. </td></tr>
    <tr><td class="paramname">UnaryPredicate</td><td>The type of the predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>The container. </td></tr>
    <tr><td class="paramname">predicate</td><td>The predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Container The filtered container. </dd></dl>

</div>
</div>
<a id="a579b90b8768aaa590ffeb462ac0d5535" name="a579b90b8768aaa590ffeb462ac0d5535"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a579b90b8768aaa590ffeb462ac0d5535">&#9670;&#160;</a></span>from_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto bricks::from_string </td>
          <td>(</td>
          <td class="paramtype">const std::string_view &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exceptionlessly convert a string to a number. </p>
<p >Example: </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> i;</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="namespacebricks.html#a579b90b8768aaa590ffeb462ac0d5535">bricks::from_string</a>(<span class="stringliteral">&quot;42&quot;</span>, i)) {</div>
<div class="line">  std::cout &lt;&lt; i &lt;&lt; std::endl; <span class="comment">// prints 42</span></div>
<div class="line">}</div>
<div class="ttc" id="anamespacebricks_html_a579b90b8768aaa590ffeb462ac0d5535"><div class="ttname"><a href="namespacebricks.html#a579b90b8768aaa590ffeb462ac0d5535">bricks::from_string</a></div><div class="ttdeci">auto from_string(const std::string_view &amp;str, T &amp;value) noexcept -&gt; bool</div><div class="ttdoc">Exceptionlessly convert a string to a number.</div><div class="ttdef"><b>Definition:</b> charconv.hpp:54</div></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of number to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to convert. </td></tr>
    <tr><td class="paramname">value</td><td>The number to write to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If the conversion was successful, false otherwise. </dd></dl>

</div>
</div>
<a id="a5f82ab9b5978f3b76b4de90de73a951d" name="a5f82ab9b5978f3b76b4de90de73a951d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f82ab9b5978f3b76b4de90de73a951d">&#9670;&#160;</a></span>index_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container , class Value &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto bricks::index_of </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Value &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::optional&lt;size_t&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the index of the first occurence of a value in a container. </p>
<p >If the container has a <code>find</code> method, it will be used to get the index of the value. Otherwise, the container will be searched using <code>std::find</code>. If <code>std::find</code> is used, the container must have a <code>begin</code> and <code>end</code> method. If the container has a <code>find</code> method, the container must have a <code>key_type</code> type alias. If <code>std::find</code> throws an exception, <code>std::terminate</code> will be called.</p>
<p >Example: </p><div class="fragment"><div class="line">    std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5};</div>
<div class="line">    INFO(<a class="code hl_function" href="namespacebricks.html#a5f82ab9b5978f3b76b4de90de73a951d">bricks::index_of</a>(vec, 3));  <span class="comment">// prints 2</span></div>
<div class="ttc" id="anamespacebricks_html_a5f82ab9b5978f3b76b4de90de73a951d"><div class="ttname"><a href="namespacebricks.html#a5f82ab9b5978f3b76b4de90de73a951d">bricks::index_of</a></div><div class="ttdeci">constexpr auto index_of(const Container &amp;container, const Value &amp;value) noexcept -&gt; std::optional&lt; size_t &gt;</div><div class="ttdoc">Get the index of the first occurence of a value in a container.</div><div class="ttdef"><b>Definition:</b> algorithm.hpp:158</div></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>The type of the container. </td></tr>
    <tr><td class="paramname">Value</td><td>The type of value to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>The container. </td></tr>
    <tr><td class="paramname">value</td><td>The value to get the index of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>constexpr std::optional&lt;size_t&gt; The index of the value, if it exists. </dd></dl>

</div>
</div>
<a id="a0ad262015be72bc9400dd9332ddc3b03" name="a0ad262015be72bc9400dd9332ddc3b03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ad262015be72bc9400dd9332ddc3b03">&#9670;&#160;</a></span>index_of_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container , class UnaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto bricks::index_of_if </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UnaryPredicate &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::optional&lt;size_t&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the index of the first element in a container for which a predicate is true. </p>
<p >Example: </p><div class="fragment"><div class="line">    std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5};</div>
<div class="line">    INFO(<a class="code hl_function" href="namespacebricks.html#a0ad262015be72bc9400dd9332ddc3b03">bricks::index_of_if</a>(vec, [](<span class="keywordtype">int</span> i) { <span class="keywordflow">return</span> i % 2 == 0; }));  <span class="comment">// prints 1</span></div>
<div class="ttc" id="anamespacebricks_html_a0ad262015be72bc9400dd9332ddc3b03"><div class="ttname"><a href="namespacebricks.html#a0ad262015be72bc9400dd9332ddc3b03">bricks::index_of_if</a></div><div class="ttdeci">constexpr auto index_of_if(const Container &amp;container, const UnaryPredicate &amp;predicate) -&gt; std::optional&lt; size_t &gt;</div><div class="ttdoc">Get the index of the first element in a container for which a predicate is true.</div><div class="ttdef"><b>Definition:</b> algorithm.hpp:177</div></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>The type of the container. </td></tr>
    <tr><td class="paramname">UnaryPredicate</td><td>The type of the predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>The container. </td></tr>
    <tr><td class="paramname">predicate</td><td>The predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>constexpr std::optional&lt;size_t&gt; The index of the value, if it exists. </dd></dl>

</div>
</div>
<a id="afec1449ef3e22e63547887744c4111a9" name="afec1449ef3e22e63547887744c4111a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afec1449ef3e22e63547887744c4111a9">&#9670;&#160;</a></span>is_ready_after()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Rep , class Period &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto bricks::is_ready_after </td>
          <td>(</td>
          <td class="paramtype">const std::future&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>future</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::duration&lt; Rep, Period &gt; &amp;&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether a future is ready after a timeout. </p>
<p >Example: </p><div class="fragment"><div class="line">    <span class="keyword">auto</span> future = std::async(std::launch::async, []() {</div>
<div class="line">      std::this_thread::sleep_for(std::chrono::milliseconds(5));</div>
<div class="line">      <span class="keywordflow">return</span> 42;</div>
<div class="line">    });</div>
<div class="line">    <span class="comment">// Will print &quot;Future is ready!&quot; after 10 milliseconds.</span></div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code hl_function" href="namespacebricks.html#afec1449ef3e22e63547887744c4111a9">bricks::is_ready_after</a>(future, std::chrono::seconds(10))) {</div>
<div class="line">      INFO(<span class="stringliteral">&quot;Future is ready!&quot;</span>);</div>
<div class="line">    }</div>
<div class="ttc" id="anamespacebricks_html_afec1449ef3e22e63547887744c4111a9"><div class="ttname"><a href="namespacebricks.html#afec1449ef3e22e63547887744c4111a9">bricks::is_ready_after</a></div><div class="ttdeci">auto is_ready_after(const std::future&lt; T &gt; &amp;future, const std::chrono::duration&lt; Rep, Period &gt; &amp;timeout) noexcept -&gt; bool</div><div class="ttdoc">Check whether a future is ready after a timeout.</div><div class="ttdef"><b>Definition:</b> algorithm.hpp:197</div></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the future. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">future</td><td>The future. </td></tr>
    <tr><td class="paramname">timeout</td><td>The timeout. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If the future is ready, false otherwise. </dd></dl>

</div>
</div>
<a id="a81e2fa4c1a3e3459b3cea78f1d796564" name="a81e2fa4c1a3e3459b3cea78f1d796564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81e2fa4c1a3e3459b3cea78f1d796564">&#9670;&#160;</a></span>is_ready_at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Clock , class Duration &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto bricks::is_ready_at </td>
          <td>(</td>
          <td class="paramtype">const std::future&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>future</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::time_point&lt; Clock, Duration &gt; &amp;&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether a future is ready at a specific time. </p>
<p >Example: </p><div class="fragment"><div class="line">    <span class="keyword">auto</span> future = std::async(std::launch::async, []() {</div>
<div class="line">      std::this_thread::sleep_for(std::chrono::milliseconds(5));</div>
<div class="line">      <span class="keywordflow">return</span> 42;</div>
<div class="line">    });</div>
<div class="line">    <span class="comment">// Will print &quot;Future is ready!&quot; after 10 milliseconds.</span></div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code hl_function" href="namespacebricks.html#a81e2fa4c1a3e3459b3cea78f1d796564">bricks::is_ready_at</a>(future, std::chrono::steady_clock::now() + std::chrono::seconds(10))) {</div>
<div class="line">      INFO(<span class="stringliteral">&quot;Future is ready!&quot;</span>);</div>
<div class="line">    }</div>
<div class="ttc" id="anamespacebricks_html_a81e2fa4c1a3e3459b3cea78f1d796564"><div class="ttname"><a href="namespacebricks.html#a81e2fa4c1a3e3459b3cea78f1d796564">bricks::is_ready_at</a></div><div class="ttdeci">auto is_ready_at(const std::future&lt; T &gt; &amp;future, const std::chrono::time_point&lt; Clock, Duration &gt; &amp;timeout) noexcept -&gt; bool</div><div class="ttdoc">Check whether a future is ready at a specific time.</div><div class="ttdef"><b>Definition:</b> algorithm.hpp:215</div></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the future. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">future</td><td>The future. </td></tr>
    <tr><td class="paramname">timeout</td><td>The timeout. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If the future is ready, false otherwise. </dd></dl>

</div>
</div>
<a id="a86002e9c15976d8002fb8b18f6f20c84" name="a86002e9c15976d8002fb8b18f6f20c84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86002e9c15976d8002fb8b18f6f20c84">&#9670;&#160;</a></span>keys()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto bricks::keys </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>input_map</em></td><td>)</td>
          <td> -&gt; std::vector&lt;typename Container::key_type&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the keys of an associative container. </p>
<p >Example: </p><div class="fragment"><div class="line">    std::map&lt;std::string, int&gt; map = {{<span class="stringliteral">&quot;a&quot;</span>, 1}, {<span class="stringliteral">&quot;b&quot;</span>, 2}, {<span class="stringliteral">&quot;c&quot;</span>, 3}};</div>
<div class="line">    <span class="keyword">auto</span> <a class="code hl_function" href="namespacebricks.html#a86002e9c15976d8002fb8b18f6f20c84">keys</a> = <a class="code hl_function" href="namespacebricks.html#a86002e9c15976d8002fb8b18f6f20c84">bricks::keys</a>(map);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> key : <a class="code hl_function" href="namespacebricks.html#a86002e9c15976d8002fb8b18f6f20c84">keys</a>) {</div>
<div class="line">      INFO(key);  <span class="comment">// prints &quot;a&quot;, &quot;b&quot;, &quot;c&quot;</span></div>
<div class="line">    }</div>
<div class="ttc" id="anamespacebricks_html_a86002e9c15976d8002fb8b18f6f20c84"><div class="ttname"><a href="namespacebricks.html#a86002e9c15976d8002fb8b18f6f20c84">bricks::keys</a></div><div class="ttdeci">auto keys(const Container &amp;input_map) -&gt; std::vector&lt; typename Container::key_type &gt;</div><div class="ttdoc">Get the keys of an associative container.</div><div class="ttdef"><b>Definition:</b> algorithm.hpp:25</div></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>The type of the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_map</td><td>The container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;typename Container::key_type&gt; The keys. </dd></dl>

</div>
</div>
<a id="a437b5370782493b27a27d8882521d96e" name="a437b5370782493b27a27d8882521d96e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a437b5370782493b27a27d8882521d96e">&#9670;&#160;</a></span>reverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto bricks::reverse </td>
          <td>(</td>
          <td class="paramtype">Range &amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a reverse iterator from a range. </p>
<p >This function creates a reverse iterator from a range. The range can be any type that has a rbegin and rend function. The reverse iterator can be used in a range-based for loop.</p>
<p >Example: </p><div class="fragment"><div class="line">  std::vector&lt;int&gt; v{1, 2, 3, 4, 5};</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> e : <a class="code hl_function" href="namespacebricks.html#a437b5370782493b27a27d8882521d96e">bricks::reverse</a>(v)) {</div>
<div class="line">    INFO(e);  <span class="comment">// prints 5, 4, 3, 2, 1</span></div>
<div class="line">  }</div>
<div class="ttc" id="anamespacebricks_html_a437b5370782493b27a27d8882521d96e"><div class="ttname"><a href="namespacebricks.html#a437b5370782493b27a27d8882521d96e">bricks::reverse</a></div><div class="ttdeci">auto reverse(Range &amp;range)</div><div class="ttdoc">Create a reverse iterator from a range.</div><div class="ttdef"><b>Definition:</b> reverse.hpp:22</div></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Range</td><td>The type of range to reverse. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>The range to reverse. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>auto A reverse iterator. </dd></dl>

</div>
</div>
<a id="ab48b3432f6b25c66c5669c3b5cdb6114" name="ab48b3432f6b25c66c5669c3b5cdb6114"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab48b3432f6b25c66c5669c3b5cdb6114">&#9670;&#160;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto bricks::to_string </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exceptionlessly convert a number to a string. </p>
<p >Example: </p><div class="fragment"><div class="line">std::string s;</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code hl_function" href="namespacebricks.html#ab48b3432f6b25c66c5669c3b5cdb6114">bricks::to_string</a>(42, s)) {</div>
<div class="line">  std::cout &lt;&lt; s &lt;&lt; std::endl; <span class="comment">// prints 42</span></div>
<div class="line">}</div>
<div class="ttc" id="anamespacebricks_html_ab48b3432f6b25c66c5669c3b5cdb6114"><div class="ttname"><a href="namespacebricks.html#ab48b3432f6b25c66c5669c3b5cdb6114">bricks::to_string</a></div><div class="ttdeci">auto to_string(const T &amp;value, std::string &amp;str) noexcept -&gt; bool</div><div class="ttdoc">Exceptionlessly convert a number to a string.</div><div class="ttdef"><b>Definition:</b> charconv.hpp:28</div></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of number to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The number to convert. </td></tr>
    <tr><td class="paramname">str</td><td>The string to write to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If the conversion was successful, false otherwise. </dd></dl>

</div>
</div>
<a id="a73112939fcac4c4eced690eff476e781" name="a73112939fcac4c4eced690eff476e781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73112939fcac4c4eced690eff476e781">&#9670;&#160;</a></span>values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto bricks::values </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>input_map</em></td><td>)</td>
          <td> -&gt; std::vector&lt;typename Container::mapped_type&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the values of an associative container. </p>
<p >Example: </p><div class="fragment"><div class="line">    std::map&lt;std::string, int&gt; map = {{<span class="stringliteral">&quot;a&quot;</span>, 1}, {<span class="stringliteral">&quot;b&quot;</span>, 2}, {<span class="stringliteral">&quot;c&quot;</span>, 3}};</div>
<div class="line">    <span class="keyword">auto</span> <a class="code hl_function" href="namespacebricks.html#a73112939fcac4c4eced690eff476e781">values</a> = <a class="code hl_function" href="namespacebricks.html#a73112939fcac4c4eced690eff476e781">bricks::values</a>(map);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> value : <a class="code hl_function" href="namespacebricks.html#a73112939fcac4c4eced690eff476e781">values</a>) {</div>
<div class="line">      INFO(value);  <span class="comment">// prints 1, 2, 3</span></div>
<div class="line">    }</div>
<div class="ttc" id="anamespacebricks_html_a73112939fcac4c4eced690eff476e781"><div class="ttname"><a href="namespacebricks.html#a73112939fcac4c4eced690eff476e781">bricks::values</a></div><div class="ttdeci">auto values(const Container &amp;input_map) -&gt; std::vector&lt; typename Container::mapped_type &gt;</div><div class="ttdoc">Get the values of an associative container.</div><div class="ttdef"><b>Definition:</b> algorithm.hpp:46</div></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>The type of the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_map</td><td>The container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;typename Container::mapped_type&gt; The values. </dd></dl>

</div>
</div>
<a id="a464e63cab89ecd30b76fb2f3ed206f00" name="a464e63cab89ecd30b76fb2f3ed206f00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a464e63cab89ecd30b76fb2f3ed206f00">&#9670;&#160;</a></span>zip()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ranges&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto bricks::zip </td>
          <td>(</td>
          <td class="paramtype">Ranges &amp;&amp;...&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A zip iterator adapter. </p>
<p >This iterator allows to iterate over multiple containers at the same time. It is similar to the zip function in python. The iterator will iterate over the shortest container. The iterator will dereference to a tuple of references to the elements of the containers.</p>
<p >Example: </p><div class="fragment"><div class="line">  std::vector&lt;int&gt; a{1, 2, 3};</div>
<div class="line">  std::vector&lt;int&gt; b{4, 5, 6};</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> [x, y] : <a class="code hl_function" href="namespacebricks.html#a464e63cab89ecd30b76fb2f3ed206f00">bricks::zip</a>(a, b)) {</div>
<div class="line">    <span class="keyword">auto</span> sum = x + y;</div>
<div class="line">    INFO(sum);  <span class="comment">// prints 5, 7, 9</span></div>
<div class="line">  }</div>
<div class="ttc" id="anamespacebricks_html_a464e63cab89ecd30b76fb2f3ed206f00"><div class="ttname"><a href="namespacebricks.html#a464e63cab89ecd30b76fb2f3ed206f00">bricks::zip</a></div><div class="ttdeci">auto zip(Ranges &amp;&amp;... t)</div><div class="ttdoc">A zip iterator adapter.</div><div class="ttdef"><b>Definition:</b> zip.hpp:19</div></div>
</div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="af33da0798fa7e1c13559de8d320713de" name="af33da0798fa7e1c13559de8d320713de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af33da0798fa7e1c13559de8d320713de">&#9670;&#160;</a></span>always_false_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool bricks::always_false_v = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template for static assertions. </p>

</div>
</div>
<a id="a674ac3c278cdcc59916c6121329f13b8" name="a674ac3c278cdcc59916c6121329f13b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a674ac3c278cdcc59916c6121329f13b8">&#9670;&#160;</a></span>is_iterator_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool bricks::is_iterator_v = <a class="el" href="structbricks_1_1is__iterator.html">is_iterator</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template to check if a type is an iterator. </p>
<p >Example: </p><div class="fragment"><div class="line"><span class="keyword">static_assert</span>(!bricks::is_iterator_v&lt;int&gt;);</div>
<div class="line"><span class="keyword">static_assert</span>(bricks::is_iterator_v&lt;std::vector&lt;int&gt;::iterator&gt;);</div>
<div class="line"><span class="keyword">static_assert</span>(bricks::is_iterator_v&lt;std::vector&lt;int&gt;::const_iterator&gt;);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacebricks.html">bricks</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
