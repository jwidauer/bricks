<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html
    PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=9" />
    <meta http-equiv="Permissions-Policy" content="interest-cohort=()" />
    <meta name="generator" content="Doxygen 1.12.0" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>BRICKS: bricks Namespace Reference</title>
    <link href="tabs.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
    <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
    <script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
    <script type="text/javascript">
        DoxygenAwesomeDarkModeToggle.init()
    </script>
    <script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
    <script type="text/javascript">
        DoxygenAwesomeFragmentCopyButton.init()
    </script>
    <script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
    <script type="text/javascript">
        DoxygenAwesomeParagraphLink.init()
    </script>
    <script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
    <script type="text/javascript">
        DoxygenAwesomeInteractiveToc.init()
    </script>
</head>
<body>
    <div id="top">
        <!-- do not remove this div, it is closed by doxygen! -->
        <div id="titlearea">
            <table cellspacing="0" cellpadding="0">
                <tbody>
                    <tr style="height: 56px;">
                        <td id="projectlogo"><img alt="Logo" src="logo.png" /></td>
                        <td id="projectalign" style="padding-left: 0.5em;">
                            <div id="projectname">BRICKS
                            </div>
                            <div id="projectbrief">Small, useful blocks of code, to build bigger things.</div>
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
        <!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('namespacebricks.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">bricks Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbricks_1_1bad__result__access.html">bad_result_access</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the type of the error thrown when accessing a bad result.  <a href="classbricks_1_1bad__result__access.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbricks_1_1deleter.html">deleter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A deleter is a function that deletes a pointer.  <a href="structbricks_1_1deleter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbricks_1_1has__find.html">has_find</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a type has a <code>find</code> method taking a specific type.  <a href="structbricks_1_1has__find.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbricks_1_1is__iterator.html">is_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a type is an iterator.  <a href="structbricks_1_1is__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbricks_1_1mutex.html">mutex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mutual exclusion primitive that can be used to protect shared data.  <a href="classbricks_1_1mutex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbricks_1_1result.html">result</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to represent the result of an operation.  <a href="classbricks_1_1result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbricks_1_1rw__lock.html">rw_lock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reader-writer lock.  <a href="classbricks_1_1rw__lock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbricks_1_1timer.html">timer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A timer that can be started and aborted.  <a href="classbricks_1_1timer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a1632d727ef97425c39f3f74abb724004" id="r_a1632d727ef97425c39f3f74abb724004"><td class="memTemplParams" colspan="2">template&lt;typename T , auto fn&gt; </td></tr>
<tr class="memitem:a1632d727ef97425c39f3f74abb724004"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1632d727ef97425c39f3f74abb724004">handle</a> = std::unique_ptr&lt;T, <a class="el" href="structbricks_1_1deleter.html">deleter</a>&lt;T, fn&gt;&gt;</td></tr>
<tr class="memdesc:a1632d727ef97425c39f3f74abb724004"><td class="mdescLeft">&#160;</td><td class="mdescRight">A handle is a unique_ptr with a custom deleter.  <br /></td></tr>
<tr class="separator:a1632d727ef97425c39f3f74abb724004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8094fb0cc36df9559ace847df128d459" id="r_a8094fb0cc36df9559ace847df128d459"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8094fb0cc36df9559ace847df128d459"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8094fb0cc36df9559ace847df128d459">ok</a> = detail::value_container&lt;T, detail::ok_tag&gt;</td></tr>
<tr class="separator:a8094fb0cc36df9559ace847df128d459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a916b884ff865df44c4abdd4e0e92fd04" id="r_a916b884ff865df44c4abdd4e0e92fd04"><td class="memTemplParams" colspan="2">template&lt;typename E &gt; </td></tr>
<tr class="memitem:a916b884ff865df44c4abdd4e0e92fd04"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a916b884ff865df44c4abdd4e0e92fd04">err</a> = detail::value_container&lt;E, detail::err_tag&gt;</td></tr>
<tr class="separator:a916b884ff865df44c4abdd4e0e92fd04"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a86002e9c15976d8002fb8b18f6f20c84" id="r_a86002e9c15976d8002fb8b18f6f20c84"><td class="memTemplParams" colspan="2">template&lt;class Container &gt; </td></tr>
<tr class="memitem:a86002e9c15976d8002fb8b18f6f20c84"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a86002e9c15976d8002fb8b18f6f20c84">keys</a> (const Container &amp;input_map) -&gt; std::vector&lt; typename Container::key_type &gt;</td></tr>
<tr class="memdesc:a86002e9c15976d8002fb8b18f6f20c84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the keys of an associative container.  <br /></td></tr>
<tr class="separator:a86002e9c15976d8002fb8b18f6f20c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73112939fcac4c4eced690eff476e781" id="r_a73112939fcac4c4eced690eff476e781"><td class="memTemplParams" colspan="2">template&lt;class Container &gt; </td></tr>
<tr class="memitem:a73112939fcac4c4eced690eff476e781"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a73112939fcac4c4eced690eff476e781">values</a> (const Container &amp;input_map) -&gt; std::vector&lt; typename Container::mapped_type &gt;</td></tr>
<tr class="memdesc:a73112939fcac4c4eced690eff476e781"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the values of an associative container.  <br /></td></tr>
<tr class="separator:a73112939fcac4c4eced690eff476e781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ad8c274821ef9eaf034b382a7dfadaf" id="r_a6ad8c274821ef9eaf034b382a7dfadaf"><td class="memTemplParams" colspan="2">template&lt;typename F , typename... FrontArgs&gt; </td></tr>
<tr class="memitem:a6ad8c274821ef9eaf034b382a7dfadaf"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6ad8c274821ef9eaf034b382a7dfadaf">bind_front</a> (F &amp;&amp;f, FrontArgs &amp;&amp;... front_args)</td></tr>
<tr class="memdesc:a6ad8c274821ef9eaf034b382a7dfadaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind arguments to the front of a function.  <br /></td></tr>
<tr class="separator:a6ad8c274821ef9eaf034b382a7dfadaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b10cd3eefc9387e44407e45c0cfc9c2" id="r_a2b10cd3eefc9387e44407e45c0cfc9c2"><td class="memTemplParams" colspan="2">template&lt;class Container , class Value &gt; </td></tr>
<tr class="memitem:a2b10cd3eefc9387e44407e45c0cfc9c2"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2b10cd3eefc9387e44407e45c0cfc9c2">contains</a> (const Container &amp;container, const Value &amp;value) noexcept -&gt; bool</td></tr>
<tr class="memdesc:a2b10cd3eefc9387e44407e45c0cfc9c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a container contains a specific value.  <br /></td></tr>
<tr class="separator:a2b10cd3eefc9387e44407e45c0cfc9c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af648dddfb613afc30701c8df34f0bb19" id="r_af648dddfb613afc30701c8df34f0bb19"><td class="memTemplParams" colspan="2">template&lt;class Container , class UnaryPredicate &gt; </td></tr>
<tr class="memitem:af648dddfb613afc30701c8df34f0bb19"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af648dddfb613afc30701c8df34f0bb19">contains_if</a> (const Container &amp;container, const UnaryPredicate &amp;predicate) -&gt; bool</td></tr>
<tr class="memdesc:af648dddfb613afc30701c8df34f0bb19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a container contains a value that satisfies a predicate.  <br /></td></tr>
<tr class="separator:af648dddfb613afc30701c8df34f0bb19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f82ab9b5978f3b76b4de90de73a951d" id="r_a5f82ab9b5978f3b76b4de90de73a951d"><td class="memTemplParams" colspan="2">template&lt;class Container , class Value &gt; </td></tr>
<tr class="memitem:a5f82ab9b5978f3b76b4de90de73a951d"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5f82ab9b5978f3b76b4de90de73a951d">index_of</a> (const Container &amp;container, const Value &amp;value) noexcept -&gt; std::optional&lt; size_t &gt;</td></tr>
<tr class="memdesc:a5f82ab9b5978f3b76b4de90de73a951d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of the first occurence of a value in a container.  <br /></td></tr>
<tr class="separator:a5f82ab9b5978f3b76b4de90de73a951d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ad262015be72bc9400dd9332ddc3b03" id="r_a0ad262015be72bc9400dd9332ddc3b03"><td class="memTemplParams" colspan="2">template&lt;class Container , class UnaryPredicate &gt; </td></tr>
<tr class="memitem:a0ad262015be72bc9400dd9332ddc3b03"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0ad262015be72bc9400dd9332ddc3b03">index_of_if</a> (const Container &amp;container, const UnaryPredicate &amp;predicate) -&gt; std::optional&lt; size_t &gt;</td></tr>
<tr class="memdesc:a0ad262015be72bc9400dd9332ddc3b03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of the first element in a container for which a predicate is true.  <br /></td></tr>
<tr class="separator:a0ad262015be72bc9400dd9332ddc3b03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afec1449ef3e22e63547887744c4111a9" id="r_afec1449ef3e22e63547887744c4111a9"><td class="memTemplParams" colspan="2">template&lt;class T , class Rep , class Period &gt; </td></tr>
<tr class="memitem:afec1449ef3e22e63547887744c4111a9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afec1449ef3e22e63547887744c4111a9">is_ready_after</a> (const std::future&lt; T &gt; &amp;future, const std::chrono::duration&lt; Rep, Period &gt; &amp;timeout) noexcept -&gt; bool</td></tr>
<tr class="memdesc:afec1449ef3e22e63547887744c4111a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a future is ready after a timeout.  <br /></td></tr>
<tr class="separator:afec1449ef3e22e63547887744c4111a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e2fa4c1a3e3459b3cea78f1d796564" id="r_a81e2fa4c1a3e3459b3cea78f1d796564"><td class="memTemplParams" colspan="2">template&lt;class T , class Clock , class Duration &gt; </td></tr>
<tr class="memitem:a81e2fa4c1a3e3459b3cea78f1d796564"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a81e2fa4c1a3e3459b3cea78f1d796564">is_ready_at</a> (const std::future&lt; T &gt; &amp;future, const std::chrono::time_point&lt; Clock, Duration &gt; &amp;timeout) noexcept -&gt; bool</td></tr>
<tr class="memdesc:a81e2fa4c1a3e3459b3cea78f1d796564"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a future is ready at a specific time.  <br /></td></tr>
<tr class="separator:a81e2fa4c1a3e3459b3cea78f1d796564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a160a4be43d95d684366925d6028a406b" id="r_a160a4be43d95d684366925d6028a406b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a160a4be43d95d684366925d6028a406b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a160a4be43d95d684366925d6028a406b">to_string</a> (const T &amp;value, std::size_t buffer_size=(std::numeric_limits&lt; T &gt;::digits10+2)) noexcept -&gt; <a class="el" href="classbricks_1_1result.html">result</a>&lt; std::string, std::errc &gt;</td></tr>
<tr class="memdesc:a160a4be43d95d684366925d6028a406b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exceptionlessly convert a number to a string.  <br /></td></tr>
<tr class="separator:a160a4be43d95d684366925d6028a406b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a006beff646c0efb0edfea15c733b224b" id="r_a006beff646c0efb0edfea15c733b224b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a006beff646c0efb0edfea15c733b224b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a006beff646c0efb0edfea15c733b224b">from_string</a> (const std::string_view &amp;str) noexcept -&gt; <a class="el" href="classbricks_1_1result.html">result</a>&lt; T, std::errc &gt;</td></tr>
<tr class="memdesc:a006beff646c0efb0edfea15c733b224b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exceptionlessly convert a string to a number.  <br /></td></tr>
<tr class="separator:a006beff646c0efb0edfea15c733b224b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3ae00555224508fa002c2d40d0c83b0" id="r_ab3ae00555224508fa002c2d40d0c83b0"><td class="memTemplParams" colspan="2">template&lt;typename Range &gt; </td></tr>
<tr class="memitem:ab3ae00555224508fa002c2d40d0c83b0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab3ae00555224508fa002c2d40d0c83b0">enumerate</a> (Range &amp;range)</td></tr>
<tr class="memdesc:ab3ae00555224508fa002c2d40d0c83b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumerate a range.  <br /></td></tr>
<tr class="separator:ab3ae00555224508fa002c2d40d0c83b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a194c2c26258519b6b094c6911cbbae6e" id="r_a194c2c26258519b6b094c6911cbbae6e"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename UnaryPredicate &gt; </td></tr>
<tr class="memitem:a194c2c26258519b6b094c6911cbbae6e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a194c2c26258519b6b094c6911cbbae6e">filter</a> (Range &amp;range, UnaryPredicate predicate) -&gt; detail::filterer&lt; Range, UnaryPredicate &gt;</td></tr>
<tr class="memdesc:a194c2c26258519b6b094c6911cbbae6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter a range.  <br /></td></tr>
<tr class="separator:a194c2c26258519b6b094c6911cbbae6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a437b5370782493b27a27d8882521d96e" id="r_a437b5370782493b27a27d8882521d96e"><td class="memTemplParams" colspan="2">template&lt;typename Range &gt; </td></tr>
<tr class="memitem:a437b5370782493b27a27d8882521d96e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a437b5370782493b27a27d8882521d96e">reverse</a> (Range &amp;range)</td></tr>
<tr class="memdesc:a437b5370782493b27a27d8882521d96e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a reverse iterator from a range.  <br /></td></tr>
<tr class="separator:a437b5370782493b27a27d8882521d96e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a464e63cab89ecd30b76fb2f3ed206f00" id="r_a464e63cab89ecd30b76fb2f3ed206f00"><td class="memTemplParams" colspan="2">template&lt;typename... Ranges&gt; </td></tr>
<tr class="memitem:a464e63cab89ecd30b76fb2f3ed206f00"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a464e63cab89ecd30b76fb2f3ed206f00">zip</a> (Ranges &amp;&amp;... t)</td></tr>
<tr class="memdesc:a464e63cab89ecd30b76fb2f3ed206f00"><td class="mdescLeft">&#160;</td><td class="mdescRight">A zip iterator adapter.  <br /></td></tr>
<tr class="separator:a464e63cab89ecd30b76fb2f3ed206f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:af33da0798fa7e1c13559de8d320713de" id="r_af33da0798fa7e1c13559de8d320713de"><td class="memTemplParams" colspan="2">template&lt;class &gt; </td></tr>
<tr class="memitem:af33da0798fa7e1c13559de8d320713de"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af33da0798fa7e1c13559de8d320713de">always_false_v</a> = false</td></tr>
<tr class="memdesc:af33da0798fa7e1c13559de8d320713de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template for static assertions.  <br /></td></tr>
<tr class="separator:af33da0798fa7e1c13559de8d320713de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a674ac3c278cdcc59916c6121329f13b8" id="r_a674ac3c278cdcc59916c6121329f13b8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a674ac3c278cdcc59916c6121329f13b8"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a674ac3c278cdcc59916c6121329f13b8">is_iterator_v</a> = <a class="el" href="structbricks_1_1is__iterator.html">is_iterator</a>&lt;T&gt;::value</td></tr>
<tr class="memdesc:a674ac3c278cdcc59916c6121329f13b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper variable template to check if a type is an iterator.  <br /></td></tr>
<tr class="separator:a674ac3c278cdcc59916c6121329f13b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a916b884ff865df44c4abdd4e0e92fd04" name="a916b884ff865df44c4abdd4e0e92fd04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a916b884ff865df44c4abdd4e0e92fd04">&#9670;&#160;</a></span>err</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a916b884ff865df44c4abdd4e0e92fd04">bricks::err</a> = detail::value_container&lt;E, detail::err_tag&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1632d727ef97425c39f3f74abb724004" name="a1632d727ef97425c39f3f74abb724004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1632d727ef97425c39f3f74abb724004">&#9670;&#160;</a></span>handle</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , auto fn&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a1632d727ef97425c39f3f74abb724004">bricks::handle</a> = std::unique_ptr&lt;T, <a class="el" href="structbricks_1_1deleter.html">deleter</a>&lt;T, fn&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A handle is a unique_ptr with a custom deleter. </p>
<p>Example: </p><div class="fragment"><div class="line">    <span class="keyword">using </span>file = <a class="code hl_typedef" href="#a1632d727ef97425c39f3f74abb724004">bricks::handle&lt;FILE, fclose&gt;</a>;</div>
<div class="line">    <span class="keyword">auto</span> f = file{fopen(<span class="stringliteral">&quot;test.txt&quot;</span>, <span class="stringliteral">&quot;w&quot;</span>)};</div>
<div class="line">    <span class="comment">// f is automatically closed when it goes out of scope</span></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the handle. </td></tr>
    <tr><td class="paramname">fn</td><td>The deleter function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8094fb0cc36df9559ace847df128d459" name="a8094fb0cc36df9559ace847df128d459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8094fb0cc36df9559ace847df128d459">&#9670;&#160;</a></span>ok</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a8094fb0cc36df9559ace847df128d459">bricks::ok</a> = detail::value_container&lt;T, detail::ok_tag&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a6ad8c274821ef9eaf034b382a7dfadaf" name="a6ad8c274821ef9eaf034b382a7dfadaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ad8c274821ef9eaf034b382a7dfadaf">&#9670;&#160;</a></span>bind_front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename... FrontArgs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto bricks::bind_front </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>f</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FrontArgs &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>front_args</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind arguments to the front of a function. </p>
<p>C++17 implementation of the C++20 <code>std::bind_front(...)</code> function.</p>
<p>Example: </p><div class="fragment"><div class="line">    <span class="keyword">auto</span> add = [](<span class="keywordtype">int</span> a, <span class="keywordtype">int</span> b) { <span class="keywordflow">return</span> a + b; };</div>
<div class="line">    <span class="keyword">auto</span> add_1 = <a class="code hl_function" href="#a6ad8c274821ef9eaf034b382a7dfadaf">bricks::bind_front</a>(add, 1);</div>
<div class="line">    INFO(add_1(2));  <span class="comment">// prints 3</span></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function to bind front arguments to. </td></tr>
    <tr><td class="paramname">front_args</td><td>The front arguments to bind. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b10cd3eefc9387e44407e45c0cfc9c2" name="a2b10cd3eefc9387e44407e45c0cfc9c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b10cd3eefc9387e44407e45c0cfc9c2">&#9670;&#160;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container , class Value &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto bricks::contains </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;</td>          <td class="paramname"><span class="paramname"><em>container</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Value &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether a container contains a specific value. </p>
<p>If the container has a <code>find</code> method, it will be used to check if the container contains the value. Otherwise, the container will be searched using <code>std::find</code>. If <code>std::find</code> is used, the container must have a <code>begin</code> and <code>end</code> method. If the container has a <code>find</code> method, the container must have a <code>key_type</code> type alias. If <code>std::find</code> throws an exception, <code>std::terminate</code> will be called.</p>
<p>Example: </p><div class="fragment"><div class="line">    std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5};</div>
<div class="line">    INFO(<a class="code hl_function" href="#a2b10cd3eefc9387e44407e45c0cfc9c2">bricks::contains</a>(vec, 3));  <span class="comment">// prints true</span></div>
<div class="line">    INFO(<a class="code hl_function" href="#a2b10cd3eefc9387e44407e45c0cfc9c2">bricks::contains</a>(vec, 6));  <span class="comment">// prints false</span></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>The type of the container. </td></tr>
    <tr><td class="paramname">Value</td><td>The type of the value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>The container. </td></tr>
    <tr><td class="paramname">value</td><td>The value to check for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If the container contains the value, false otherwise. </dd></dl>

</div>
</div>
<a id="af648dddfb613afc30701c8df34f0bb19" name="af648dddfb613afc30701c8df34f0bb19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af648dddfb613afc30701c8df34f0bb19">&#9670;&#160;</a></span>contains_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container , class UnaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto bricks::contains_if </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;</td>          <td class="paramname"><span class="paramname"><em>container</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UnaryPredicate &amp;</td>          <td class="paramname"><span class="paramname"><em>predicate</em></span>&#160;) -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a container contains a value that satisfies a predicate. </p>
<p>Example: </p><div class="fragment"><div class="line">    std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5};</div>
<div class="line">    INFO(<a class="code hl_function" href="#af648dddfb613afc30701c8df34f0bb19">bricks::contains_if</a>(vec, [](<span class="keywordtype">int</span> i) { <span class="keywordflow">return</span> i % 2 == 0; }));  <span class="comment">// prints true</span></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>The type of the container. </td></tr>
    <tr><td class="paramname">UnaryPredicate</td><td>The type of the predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>The container. </td></tr>
    <tr><td class="paramname">predicate</td><td>The predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If the container contains a value that satisfies the predicate, false otherwise. </dd></dl>

</div>
</div>
<a id="ab3ae00555224508fa002c2d40d0c83b0" name="ab3ae00555224508fa002c2d40d0c83b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3ae00555224508fa002c2d40d0c83b0">&#9670;&#160;</a></span>enumerate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto bricks::enumerate </td>
          <td>(</td>
          <td class="paramtype">Range &amp;</td>          <td class="paramname"><span class="paramname"><em>range</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumerate a range. </p>
<p>This function creates an iterator adapter that enumerates the values of a range. The range can be any type that has a begin and end function. Each element in the enumerator is a pair of the index and the value.</p>
<p>Example: </p><div class="fragment"><div class="line">  std::vector&lt;int&gt; v{1, 2, 3, 4, 5};</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> [i, e] : <a class="code hl_function" href="#ab3ae00555224508fa002c2d40d0c83b0">bricks::enumerate</a>(v)) {</div>
<div class="line">    <span class="keyword">auto</span> idx = i;</div>
<div class="line">    <span class="keyword">auto</span> elem = e;</div>
<div class="line">    INFO(idx, <span class="stringliteral">&quot;: &quot;</span>, elem);  <span class="comment">// prints 0: 1, 1: 2, 2: 3, 3: 4, 4: 5</span></div>
<div class="line">  }</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Range</td><td>The type of range to enumerate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>The range to enumerate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>auto An enumerator. </dd></dl>

</div>
</div>
<a id="a194c2c26258519b6b094c6911cbbae6e" name="a194c2c26258519b6b094c6911cbbae6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a194c2c26258519b6b094c6911cbbae6e">&#9670;&#160;</a></span>filter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename UnaryPredicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto bricks::filter </td>
          <td>(</td>
          <td class="paramtype">Range &amp;</td>          <td class="paramname"><span class="paramname"><em>range</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryPredicate</td>          <td class="paramname"><span class="paramname"><em>predicate</em></span>&#160;) -&gt; detail::filterer&lt;Range, UnaryPredicate&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filter a range. </p>
<p>This function creates an iterator adapter that filters the values of a range. The range can be any type that has a begin and end function. Each element in the iterator adapter is a value that satisfies the predicate.</p>
<p>Example: </p><div class="fragment"><div class="line">  std::vector&lt;int&gt; v{1, 2, 3, 4, 5};</div>
<div class="line">  <span class="keyword">auto</span> filtered = <a class="code hl_function" href="#a194c2c26258519b6b094c6911cbbae6e">bricks::filter</a>(v, [](<span class="keywordtype">int</span> i) { <span class="keywordflow">return</span> i % 2 == 0; });</div>
<div class="line">  <span class="keywordtype">int</span> expected = 2;</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> i : filtered) {</div>
<div class="line">    CHECK(i == expected);</div>
<div class="line">    expected += 2;</div>
<div class="line">  }</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>The range to filter. </td></tr>
    <tr><td class="paramname">predicate</td><td>The predicate to filter with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>auto The iterator adapter. </dd></dl>

</div>
</div>
<a id="a006beff646c0efb0edfea15c733b224b" name="a006beff646c0efb0edfea15c733b224b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a006beff646c0efb0edfea15c733b224b">&#9670;&#160;</a></span>from_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto bricks::from_string </td>
          <td>(</td>
          <td class="paramtype">const std::string_view &amp;</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td> -&gt; <a class="el" href="classbricks_1_1result.html">result</a>&lt;T, std::errc&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exceptionlessly convert a string to a number. </p>
<p>This function is a wrapper around <code>std::from_chars</code> and will return the same error codes. It, however, will return <code>std::errc::invalid_argument</code> if the string contains characters that are not part of the number.</p>
<p>Example: </p><div class="fragment"><div class="line">  <span class="keyword">auto</span> value = <a class="code hl_function" href="#a006beff646c0efb0edfea15c733b224b">bricks::from_string&lt;int&gt;</a>(<span class="stringliteral">&quot;42&quot;</span>);</div>
<div class="line">  REQUIRE(value.is_value());</div>
<div class="line">  CHECK(value.unwrap() == 42);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of number to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result&lt;T, std::errc&gt; Result of the conversion. Will contain the error code if the conversion failed. </dd></dl>

</div>
</div>
<a id="a5f82ab9b5978f3b76b4de90de73a951d" name="a5f82ab9b5978f3b76b4de90de73a951d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f82ab9b5978f3b76b4de90de73a951d">&#9670;&#160;</a></span>index_of()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container , class Value &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto bricks::index_of </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;</td>          <td class="paramname"><span class="paramname"><em>container</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Value &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;) -&gt; std::optional&lt;size_t&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the index of the first occurence of a value in a container. </p>
<p>If the container has a <code>find</code> method, it will be used to get the index of the value. Otherwise, the container will be searched using <code>std::find</code>. If <code>std::find</code> is used, the container must have a <code>begin</code> and <code>end</code> method. If the container has a <code>find</code> method, the container must have a <code>key_type</code> type alias. If <code>std::find</code> throws an exception, <code>std::terminate</code> will be called.</p>
<p>Example: </p><div class="fragment"><div class="line">    std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5};</div>
<div class="line">    INFO(<a class="code hl_function" href="#a5f82ab9b5978f3b76b4de90de73a951d">bricks::index_of</a>(vec, 3));  <span class="comment">// prints 2</span></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>The type of the container. </td></tr>
    <tr><td class="paramname">Value</td><td>The type of value to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>The container. </td></tr>
    <tr><td class="paramname">value</td><td>The value to get the index of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>constexpr std::optional&lt;size_t&gt; The index of the value, if it exists. </dd></dl>

</div>
</div>
<a id="a0ad262015be72bc9400dd9332ddc3b03" name="a0ad262015be72bc9400dd9332ddc3b03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ad262015be72bc9400dd9332ddc3b03">&#9670;&#160;</a></span>index_of_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container , class UnaryPredicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto bricks::index_of_if </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;</td>          <td class="paramname"><span class="paramname"><em>container</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UnaryPredicate &amp;</td>          <td class="paramname"><span class="paramname"><em>predicate</em></span>&#160;) -&gt; std::optional&lt;size_t&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the index of the first element in a container for which a predicate is true. </p>
<p>Example: </p><div class="fragment"><div class="line">    std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5};</div>
<div class="line">    INFO(<a class="code hl_function" href="#a0ad262015be72bc9400dd9332ddc3b03">bricks::index_of_if</a>(vec, [](<span class="keywordtype">int</span> i) { <span class="keywordflow">return</span> i % 2 == 0; }));  <span class="comment">// prints 1</span></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>The type of the container. </td></tr>
    <tr><td class="paramname">UnaryPredicate</td><td>The type of the predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>The container. </td></tr>
    <tr><td class="paramname">predicate</td><td>The predicate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>constexpr std::optional&lt;size_t&gt; The index of the value, if it exists. </dd></dl>

</div>
</div>
<a id="afec1449ef3e22e63547887744c4111a9" name="afec1449ef3e22e63547887744c4111a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afec1449ef3e22e63547887744c4111a9">&#9670;&#160;</a></span>is_ready_after()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Rep , class Period &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto bricks::is_ready_after </td>
          <td>(</td>
          <td class="paramtype">const std::future&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>future</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::duration&lt; Rep, Period &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>timeout</em></span>&#160;) -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether a future is ready after a timeout. </p>
<p>Example: </p><div class="fragment"><div class="line">    <span class="keyword">auto</span> future = std::async(std::launch::async, []() {</div>
<div class="line">      std::this_thread::sleep_for(std::chrono::milliseconds(5));</div>
<div class="line">      <span class="keywordflow">return</span> 42;</div>
<div class="line">    });</div>
<div class="line">    <span class="comment">// Will print &quot;Future is ready!&quot; after 10 milliseconds.</span></div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code hl_function" href="#afec1449ef3e22e63547887744c4111a9">bricks::is_ready_after</a>(future, std::chrono::seconds(10))) {</div>
<div class="line">      INFO(<span class="stringliteral">&quot;Future is ready!&quot;</span>);</div>
<div class="line">    }</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the future. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">future</td><td>The future. </td></tr>
    <tr><td class="paramname">timeout</td><td>The timeout. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If the future is ready, false otherwise. </dd></dl>

</div>
</div>
<a id="a81e2fa4c1a3e3459b3cea78f1d796564" name="a81e2fa4c1a3e3459b3cea78f1d796564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81e2fa4c1a3e3459b3cea78f1d796564">&#9670;&#160;</a></span>is_ready_at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Clock , class Duration &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto bricks::is_ready_at </td>
          <td>(</td>
          <td class="paramtype">const std::future&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>future</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::time_point&lt; Clock, Duration &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>timeout</em></span>&#160;) -&gt; bool
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether a future is ready at a specific time. </p>
<p>Example: </p><div class="fragment"><div class="line">    <span class="keyword">auto</span> future = std::async(std::launch::async, []() {</div>
<div class="line">      std::this_thread::sleep_for(std::chrono::milliseconds(5));</div>
<div class="line">      <span class="keywordflow">return</span> 42;</div>
<div class="line">    });</div>
<div class="line">    <span class="comment">// Will print &quot;Future is ready!&quot; after 10 milliseconds.</span></div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code hl_function" href="#a81e2fa4c1a3e3459b3cea78f1d796564">bricks::is_ready_at</a>(future, std::chrono::steady_clock::now() + std::chrono::seconds(10))) {</div>
<div class="line">      INFO(<span class="stringliteral">&quot;Future is ready!&quot;</span>);</div>
<div class="line">    }</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the future. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">future</td><td>The future. </td></tr>
    <tr><td class="paramname">timeout</td><td>The timeout. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If the future is ready, false otherwise. </dd></dl>

</div>
</div>
<a id="a86002e9c15976d8002fb8b18f6f20c84" name="a86002e9c15976d8002fb8b18f6f20c84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86002e9c15976d8002fb8b18f6f20c84">&#9670;&#160;</a></span>keys()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto bricks::keys </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;</td>          <td class="paramname"><span class="paramname"><em>input_map</em></span></td><td>)</td>
          <td> -&gt; std::vector&lt;typename Container::key_type&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the keys of an associative container. </p>
<p>Example: </p><div class="fragment"><div class="line">    std::map&lt;std::string, int&gt; map = {{<span class="stringliteral">&quot;a&quot;</span>, 1}, {<span class="stringliteral">&quot;b&quot;</span>, 2}, {<span class="stringliteral">&quot;c&quot;</span>, 3}};</div>
<div class="line">    <span class="keyword">auto</span> <a class="code hl_function" href="#a86002e9c15976d8002fb8b18f6f20c84">keys</a> = <a class="code hl_function" href="#a86002e9c15976d8002fb8b18f6f20c84">bricks::keys</a>(map);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> key : keys) {</div>
<div class="line">      INFO(key);  <span class="comment">// prints &quot;a&quot;, &quot;b&quot;, &quot;c&quot;</span></div>
<div class="line">    }</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>The type of the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_map</td><td>The container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;typename Container::key_type&gt; The keys. </dd></dl>

</div>
</div>
<a id="a437b5370782493b27a27d8882521d96e" name="a437b5370782493b27a27d8882521d96e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a437b5370782493b27a27d8882521d96e">&#9670;&#160;</a></span>reverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto bricks::reverse </td>
          <td>(</td>
          <td class="paramtype">Range &amp;</td>          <td class="paramname"><span class="paramname"><em>range</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a reverse iterator from a range. </p>
<p>This function creates a reverse iterator from a range. The range can be any type that has a rbegin and rend function.</p>
<p>Example: </p><div class="fragment"><div class="line">  std::vector&lt;int&gt; v{1, 2, 3, 4, 5};</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> e : <a class="code hl_function" href="#a437b5370782493b27a27d8882521d96e">bricks::reverse</a>(v)) {</div>
<div class="line">    INFO(e);  <span class="comment">// prints 5, 4, 3, 2, 1</span></div>
<div class="line">  }</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Range</td><td>The type of range to reverse. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>The range to reverse. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>auto A reverse iterator. </dd></dl>

</div>
</div>
<a id="a160a4be43d95d684366925d6028a406b" name="a160a4be43d95d684366925d6028a406b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a160a4be43d95d684366925d6028a406b">&#9670;&#160;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto bricks::to_string </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>buffer_size</em></span><span class="paramdefsep"> = </span><span class="paramdefval">(std::numeric_limits&lt;T&gt;::digits10&#160;+&#160;2)</span>&#160;) -&gt; <a class="el" href="classbricks_1_1result.html">result</a>&lt;std::string, std::errc&gt;
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Exceptionlessly convert a number to a string. </p>
<p>This function is a wrapper around <code>std::to_chars</code> and will return the same error codes.</p>
<p>Example: </p><div class="fragment"><div class="line">  <span class="keyword">auto</span> output = <a class="code hl_function" href="#a160a4be43d95d684366925d6028a406b">bricks::to_string</a>(42);</div>
<div class="line">  REQUIRE(output.is_value());</div>
<div class="line">  CHECK(output.unwrap() == <span class="stringliteral">&quot;42&quot;</span>);</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of number to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The number to convert. </td></tr>
    <tr><td class="paramname">buffer_size</td><td>The size of the buffer to use for the conversion. If the buffer is too small the conversion will fail with <code>std::errc::value_too_large</code>. Can be omitted if the type is an integral type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result&lt;std::string, std::errc&gt; Result of the conversion. Will contain the error code if the conversion failed. </dd></dl>

</div>
</div>
<a id="a73112939fcac4c4eced690eff476e781" name="a73112939fcac4c4eced690eff476e781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73112939fcac4c4eced690eff476e781">&#9670;&#160;</a></span>values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Container &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto bricks::values </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;</td>          <td class="paramname"><span class="paramname"><em>input_map</em></span></td><td>)</td>
          <td> -&gt; std::vector&lt;typename Container::mapped_type&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the values of an associative container. </p>
<p>Example: </p><div class="fragment"><div class="line">    std::map&lt;std::string, int&gt; map = {{<span class="stringliteral">&quot;a&quot;</span>, 1}, {<span class="stringliteral">&quot;b&quot;</span>, 2}, {<span class="stringliteral">&quot;c&quot;</span>, 3}};</div>
<div class="line">    <span class="keyword">auto</span> <a class="code hl_function" href="#a73112939fcac4c4eced690eff476e781">values</a> = <a class="code hl_function" href="#a73112939fcac4c4eced690eff476e781">bricks::values</a>(map);</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> value : values) {</div>
<div class="line">      INFO(value);  <span class="comment">// prints 1, 2, 3</span></div>
<div class="line">    }</div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Container</td><td>The type of the container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_map</td><td>The container. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;typename Container::mapped_type&gt; The values. </dd></dl>

</div>
</div>
<a id="a464e63cab89ecd30b76fb2f3ed206f00" name="a464e63cab89ecd30b76fb2f3ed206f00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a464e63cab89ecd30b76fb2f3ed206f00">&#9670;&#160;</a></span>zip()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ranges&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto bricks::zip </td>
          <td>(</td>
          <td class="paramtype">Ranges &amp;&amp;...</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A zip iterator adapter. </p>
<p>This iterator allows to iterate over multiple containers at the same time. It is similar to the zip function in python. The iterator will iterate over the shortest container. The iterator will dereference to a tuple of references to the elements of the containers.</p>
<p>Example: </p><div class="fragment"><div class="line">  std::vector&lt;int&gt; a{1, 2, 3};</div>
<div class="line">  std::vector&lt;int&gt; b{4, 5, 6};</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> [x, y] : <a class="code hl_function" href="#a464e63cab89ecd30b76fb2f3ed206f00">bricks::zip</a>(a, b)) {</div>
<div class="line">    <span class="keyword">auto</span> sum = x + y;</div>
<div class="line">    INFO(sum);  <span class="comment">// prints 5, 7, 9</span></div>
<div class="line">  }</div>
</div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="af33da0798fa7e1c13559de8d320713de" name="af33da0798fa7e1c13559de8d320713de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af33da0798fa7e1c13559de8d320713de">&#9670;&#160;</a></span>always_false_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool bricks::always_false_v = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template for static assertions. </p>

</div>
</div>
<a id="a674ac3c278cdcc59916c6121329f13b8" name="a674ac3c278cdcc59916c6121329f13b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a674ac3c278cdcc59916c6121329f13b8">&#9670;&#160;</a></span>is_iterator_v</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool bricks::is_iterator_v = <a class="el" href="structbricks_1_1is__iterator.html">is_iterator</a>&lt;T&gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper variable template to check if a type is an iterator. </p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">static_assert</span>(!<a class="code hl_variable" href="#a674ac3c278cdcc59916c6121329f13b8">bricks::is_iterator_v&lt;int&gt;</a>);</div>
<div class="line"><span class="keyword">static_assert</span>(bricks::is_iterator_v&lt;std::vector&lt;int&gt;::iterator&gt;);</div>
<div class="line"><span class="keyword">static_assert</span>(bricks::is_iterator_v&lt;std::vector&lt;int&gt;::const_iterator&gt;);</div>
<div class="ttc" id="anamespacebricks_html_a674ac3c278cdcc59916c6121329f13b8"><div class="ttname"><a href="#a674ac3c278cdcc59916c6121329f13b8">bricks::is_iterator_v</a></div><div class="ttdeci">constexpr bool is_iterator_v</div><div class="ttdoc">Helper variable template to check if a type is an iterator.</div><div class="ttdef"><b>Definition</b> type_traits.hpp:80</div></div>
<div class="ttc" id="atype__traits_8hpp_html"><div class="ttname"><a href="type__traits_8hpp.html">type_traits.hpp</a></div></div>
</div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacebricks.html">bricks</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
